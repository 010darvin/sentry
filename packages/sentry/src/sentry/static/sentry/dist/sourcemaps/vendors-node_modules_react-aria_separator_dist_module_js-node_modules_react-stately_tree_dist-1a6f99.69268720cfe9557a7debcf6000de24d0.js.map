{"version":3,"file":"chunks/vendors-node_modules_react-aria_separator_dist_module_js-node_modules_react-stately_tree_dist-1a6f99.xxxxxxxxxxxxxxxxxxxx.js","mappings":";;;;;;;;;;;;;;;AAAmD;AAC6B;;AAEhF;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,iEAAc;AAC/B;AACA,GAAG;AACH,uBAAuB;AACvB;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,sBAAsB,8EAA8B,GAAG;AACvD;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjC0D;AACR;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,SAAS;AACb;;AAEA,qBAAqB,6CAAM;AAC3B,uBAAuB,+CAAQ;AAC/B,sBAAsB,6CAAM;AAC5B,8BAA8B,6CAAM;AACpC,0BAA0B,+CAAQ;AAClC,yBAAyB,8CAAO;AAChC,4BAA4B,8CAAO;AACnC,wCAAwC,wEAAkB;AAC1D,yBAAyB,8CAAO;AAChC,kDAAkD,+CAAQ,uCAAuC;AACjG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB;AACxB;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;ACtmB0D;AACC;AAC4B;AAC5C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,wBAAwB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACO;AACP,wCAAwC,wEAAkB;AAC1D,uBAAuB,mFAAyB;AAChD,qBAAqB,8CAAO;AAC5B,aAAa,yEAAa;AAC1B;AACA,GAAG,0BAA0B;;AAE7B,EAAE,gDAAS;AACX;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sEAAgB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC1Ja;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA,4CAA4C,qBAAqB;AACjE;;AAEA;AACA,KAAK;AACL,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACjEa;;AAEb,kCAAkC;;AAElC,8BAA8B;;AAE9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK,yCAAyC,8FAA8F,wBAAwB,eAAe,eAAe,gBAAgB,YAAY,MAAM,wBAAwB,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,mDAAmD,UAAU,sBAAsB;;AAEve,gCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;;;;;;;;AC/Ba;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAkB,GAAG,gBAAgB;;AAErC,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,aAAa,mBAAO,CAAC,6CAAO;;AAE5B;;AAEA,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;;AAEA,iBAAiB,mBAAO,CAAC,uDAAY;;AAErC;;AAEA,aAAa,mBAAO,CAAC,wEAAe;;AAEpC,oBAAoB,mBAAO,CAAC,sFAAsB;;AAElD;;AAEA,gBAAgB,mBAAO,CAAC,8EAAkB;;AAE1C;;AAEA,gBAAgB,mBAAO,CAAC,8EAAkB;;AAE1C;;AAEA,uCAAuC,uCAAuC;;AAE9E,kDAAkD,0CAA0C;;AAE5F,kDAAkD,aAAa,yFAAyF;;AAExJ,2CAA2C,+DAA+D,uGAAuG,yEAAyE,eAAe,0EAA0E,GAAG,yHAAyH;AAC/e;AACA;;;AAGA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA,6CAA6C,gCAAgC;;AAE7E;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD;AAChD,kDAAkD;AAClD,oGAAoG;AACpG,mGAAmG;;AAEnG;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC,4CAA4C;;AAE5C,mIAAmI;;AAEnI;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA,mIAAmI;;AAEnI;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2IAA2I,SAAS,2BAA2B,qCAAqC;AACpN;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA,gBAAgB;AAChB,kBAAe;AACf,kBAAkB;;;;;;;;;;AC5YL;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AChDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,UAAU;AACV,WAAW;AACX;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;ACzBa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;;AAEF;AACA;AACA;;AAEA,kBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;AC3Ca;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;;;AC3Ba;;AAEb;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACvGa;;AAEb;AACA;;AAEA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;ACtCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACVa;;AAEb;AACA;AACA,cAAc,KAAwC,GAAG,sBAAiB,GAAG,CAAI;;AAEjF;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACXa;;AAEb;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;;AAEA;AACA,iFAAiF;AACjF;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA,yDAAyD;AACzD,IAAI;;AAEJ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACrEa;;AAEb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA","sources":["webpack:///../node_modules/@react-aria/separator/dist/module.js","webpack:///../node_modules/@react-stately/selection/dist/module.js","webpack:///../node_modules/@react-stately/tree/dist/module.js","webpack:///../node_modules/css-loader/dist/runtime/api.js","webpack:///../node_modules/css-loader/dist/runtime/cssWithMappingToString.js","webpack:///../node_modules/react-lazyload/lib/index.js","webpack:///../node_modules/react-lazyload/lib/utils/debounce.js","webpack:///../node_modules/react-lazyload/lib/utils/event.js","webpack:///../node_modules/react-lazyload/lib/utils/scrollParent.js","webpack:///../node_modules/react-lazyload/lib/utils/throttle.js","webpack:///../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack:///../node_modules/style-loader/dist/runtime/insertBySelector.js","webpack:///../node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack:///../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack:///../node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack:///../node_modules/style-loader/dist/runtime/styleTagTransform.js"],"sourcesContent":["import { filterDOMProps } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n\n/**\n * Provides the accessibility implementation for a separator.\n * A separator is a visual divider between two groups of content,\n * e.g. groups of menu items or sections of a page.\n */\nexport function useSeparator(props) {\n  let domProps = filterDOMProps(props, {\n    labelable: true\n  });\n  let ariaOrientation; // if orientation is horizontal, aria-orientation default is horizontal, so we leave it undefined\n  // if it's vertical, we need to specify it\n\n  if (props.orientation === 'vertical') {\n    ariaOrientation = 'vertical';\n  } // hr elements implicitly have role = separator and a horizontal orientation\n\n\n  if (props.elementType !== 'hr') {\n    return {\n      separatorProps: _babelRuntimeHelpersEsmExtends({}, domProps, {\n        role: 'separator',\n        'aria-orientation': ariaOrientation\n      })\n    };\n  }\n\n  return {\n    separatorProps: domProps\n  };\n}\n//# sourceMappingURL=module.js.map\n","import { useControlledState } from \"@react-stately/utils\";\nimport { useMemo, useRef, useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nclass $c91e86e24f2dc9a2182dcc2674c58c$export$Selection extends Set {\n  constructor(keys, anchorKey, currentKey) {\n    super(keys);\n    this.anchorKey = void 0;\n    this.currentKey = void 0;\n\n    if (keys instanceof $c91e86e24f2dc9a2182dcc2674c58c$export$Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n\n}\n\nfunction $c86d35e876e048ac11515eee40c7$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props) {\n  let {\n    selectionMode = 'none',\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents\n  } = props; // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => $c86d35e876e048ac11515eee40c7$var$convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => $c86d35e876e048ac11515eee40c7$var$convertSelection(props.defaultSelectedKeys, new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n  let disabledKeysProp = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(props.selectionBehavior || 'toggle'); // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n\n  if (props.selectionBehavior === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n\n    setFocusedKey(k, childFocusStrategy) {\n      if (childFocusStrategy === void 0) {\n        childFocusStrategy = 'first';\n      }\n\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n\n    selectedKeys,\n\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$c86d35e876e048ac11515eee40c7$var$equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n\n    disabledKeys: disabledKeysProp\n  };\n}\n\nfunction $c86d35e876e048ac11515eee40c7$var$convertSelection(selection, defaultValue) {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all' ? 'all' : new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selection);\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager {\n  constructor(collection, state, options) {\n    var _options$allowsCellSe;\n\n    this.collection = void 0;\n    this.state = void 0;\n    this.allowsCellSelection = void 0;\n    this._isSelectAll = void 0;\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = (_options$allowsCellSe = options == null ? void 0 : options.allowsCellSelection) != null ? _options$allowsCellSe : false;\n    this._isSelectAll = null;\n  }\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n\n\n  get selectionMode() {\n    return this.state.selectionMode;\n  }\n  /**\n   * Whether the collection allows empty selection.\n   */\n\n\n  get disallowEmptySelection() {\n    return this.state.disallowEmptySelection;\n  }\n  /**\n   * The selection behavior for the collection.\n   */\n\n\n  get selectionBehavior() {\n    return this.state.selectionBehavior;\n  }\n  /**\n   * Sets the selection behavior for the collection.\n   */\n\n\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  /**\n   * Whether the collection is currently focused.\n   */\n\n\n  get isFocused() {\n    return this.state.isFocused;\n  }\n  /**\n   * Sets whether the collection is focused.\n   */\n\n\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  /**\n   * The current focused key in the collection.\n   */\n\n\n  get focusedKey() {\n    return this.state.focusedKey;\n  }\n  /** Whether the first or last child of the focused key should receive focus. */\n\n\n  get childFocusStrategy() {\n    return this.state.childFocusStrategy;\n  }\n  /**\n   * Sets the focused key.\n   */\n\n\n  setFocusedKey(key, childFocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n  /**\n   * The currently selected keys in the collection.\n   */\n\n\n  get selectedKeys() {\n    return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n  }\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n\n\n  get rawSelection() {\n    return this.state.selectedKeys;\n  }\n  /**\n   * Returns whether a key is selected.\n   */\n\n\n  isSelected(key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all' ? !this.state.disabledKeys.has(key) : this.state.selectedKeys.has(key);\n  }\n  /**\n   * Whether the selection is empty.\n   */\n\n\n  get isEmpty() {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n  /**\n   * Whether all items in the collection are selected.\n   */\n\n\n  get isSelectAll() {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey() {\n    var _first;\n\n    let first = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n\n      if (!first || (item == null ? void 0 : item.index) < first.index) {\n        first = item;\n      }\n    }\n\n    return (_first = first) == null ? void 0 : _first.key;\n  }\n\n  get lastSelectedKey() {\n    var _last;\n\n    let last = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n\n      if (!last || (item == null ? void 0 : item.index) > last.index) {\n        last = item;\n      }\n    }\n\n    return (_last = last) == null ? void 0 : _last.key;\n  }\n  /**\n   * Extends the selection to the given key.\n   */\n\n\n  extendSelection(toKey) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n    let selection; // Only select the one key if coming from a select all.\n\n    if (this.state.selectedKeys === 'all') {\n      selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(selectedKeys, anchorKey, toKey);\n\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (!this.state.disabledKeys.has(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  getKeyRange(from, to) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  getKeyRangeInternal(from, to) {\n    let keys = [];\n    let key = from;\n\n    while (key) {\n      let item = this.collection.getItem(key);\n\n      if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  getKey(key) {\n    let item = this.collection.getItem(key);\n\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    } // If cell selection is allowed, just return the key.\n\n\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    } // Find a parent item to select\n\n\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n  /**\n   * Toggles whether the given key is selected.\n   */\n\n\n  toggleSelection(key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n\n    if (key == null) {\n      return;\n    }\n\n    let keys = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n\n    if (keys.has(key)) {\n      keys.delete(key); // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n  /**\n   * Replaces the selection with only the given key.\n   */\n\n\n  replaceSelection(key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n\n    if (key == null) {\n      return;\n    }\n\n    this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection([key], key, key));\n  }\n  /**\n   * Replaces the selection with the given keys.\n   */\n\n\n  setSelectedKeys(keys) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection();\n\n    for (let key of keys) {\n      key = this.getKey(key);\n\n      if (key != null) {\n        selection.add(key);\n\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  getSelectAllKeys() {\n    let keys = [];\n\n    let addKeys = key => {\n      while (key) {\n        if (!this.state.disabledKeys.has(key)) {\n          let item = this.collection.getItem(key);\n\n          if (item.type === 'item') {\n            keys.push(key);\n          } // Add child keys. If cell selection is allowed, then include item children too.\n\n\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n  /**\n   * Selects all items in the collection.\n   */\n\n\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n  /**\n   * Removes all keys from the selection.\n   */\n\n\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new $c91e86e24f2dc9a2182dcc2674c58c$export$Selection());\n    }\n  }\n  /**\n   * Toggles between select all and an empty selection.\n   */\n\n\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key, e) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || e && (e.pointerType === 'touch' || e.pointerType === 'virtual')) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n\n\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    } // Check if the set of keys match.\n\n\n    let selectedKeys = this.selectedKeys;\n\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n\n    if (!item || item.type === 'cell' && !this.allowsCellSelection) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n//# sourceMappingURL=module.js.map\n","import { useControlledState } from \"@react-stately/utils\";\nimport { useCollection } from \"@react-stately/collections\";\nimport { SelectionManager, useMultipleSelectionState } from \"@react-stately/selection\";\nimport { useEffect, useMemo } from \"react\";\nlet $afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator;\n$afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator = Symbol.iterator;\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $afa6f708e32ecf7f97d9a58dfd59c$export$TreeCollection {\n  constructor(nodes, _temp) {\n    var _last;\n\n    let {\n      expandedKeys\n    } = _temp === void 0 ? {} : _temp;\n    this.keyMap = new Map();\n    this.iterable = void 0;\n    this.firstKey = void 0;\n    this.lastKey = void 0;\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = node => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last;\n    let index = 0;\n\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node; // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = (_last = last) == null ? void 0 : _last.key;\n  }\n\n  *[$afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n}\n\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n */\nexport function useTreeState(props) {\n  let [expandedKeys, setExpandedKeys] = useControlledState(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let tree = useCollection(props, nodes => new $afa6f708e32ecf7f97d9a58dfd59c$export$TreeCollection(nodes, {\n    expandedKeys\n  }), null, [expandedKeys]); // Reset focused key if that item is deleted from the collection.\n\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  let onToggle = key => {\n    setExpandedKeys(expandedKeys => $f51dc3c5c900bd3cdb4a06df11d84697$var$toggleKey(expandedKeys, key));\n  };\n\n  return {\n    collection: tree,\n    expandedKeys,\n    disabledKeys,\n    toggleKey: onToggle,\n    selectionManager: new SelectionManager(tree, selectionState)\n  };\n}\n\nfunction $f51dc3c5c900bd3cdb4a06df11d84697$var$toggleKey(set, key) {\n  let res = new Set(set);\n\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}\n//# sourceMappingURL=module.js.map\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forceCheck = exports.lazyload = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _event = require('./utils/event');\n\nvar _scrollParent = require('./utils/scrollParent');\n\nvar _scrollParent2 = _interopRequireDefault(_scrollParent);\n\nvar _debounce = require('./utils/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nvar _throttle = require('./utils/throttle');\n\nvar _throttle2 = _interopRequireDefault(_throttle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * react-lazyload\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar defaultBoundingClientRect = { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };\nvar LISTEN_FLAG = 'data-lazyload-listened';\nvar listeners = [];\nvar pending = [];\n\n// try to handle passive events\nvar passiveEventSupported = false;\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    get: function get() {\n      passiveEventSupported = true;\n    }\n  });\n  window.addEventListener('test', null, opts);\n} catch (e) {}\n// if they are supported, setup the optional params\n// IMPORTANT: FALSE doubles as the default CAPTURE value!\nvar passiveEvent = passiveEventSupported ? { capture: false, passive: true } : false;\n\n/**\n * Check if `component` is visible in overflow container `parent`\n * @param  {node} component React component\n * @param  {node} parent    component's scroll parent\n * @return {bool}\n */\nvar checkOverflowVisible = function checkOverflowVisible(component, parent) {\n  var node = _reactDom2.default.findDOMNode(component);\n\n  var parentTop = void 0;\n  var parentLeft = void 0;\n  var parentHeight = void 0;\n  var parentWidth = void 0;\n\n  try {\n    var _parent$getBoundingCl = parent.getBoundingClientRect();\n\n    parentTop = _parent$getBoundingCl.top;\n    parentLeft = _parent$getBoundingCl.left;\n    parentHeight = _parent$getBoundingCl.height;\n    parentWidth = _parent$getBoundingCl.width;\n  } catch (e) {\n    parentTop = defaultBoundingClientRect.top;\n    parentLeft = defaultBoundingClientRect.left;\n    parentHeight = defaultBoundingClientRect.height;\n    parentWidth = defaultBoundingClientRect.width;\n  }\n\n  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;\n  var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;\n\n  // calculate top and height of the intersection of the element's scrollParent and viewport\n  var intersectionTop = Math.max(parentTop, 0); // intersection's top relative to viewport\n  var intersectionLeft = Math.max(parentLeft, 0); // intersection's left relative to viewport\n  var intersectionHeight = Math.min(windowInnerHeight, parentTop + parentHeight) - intersectionTop; // height\n  var intersectionWidth = Math.min(windowInnerWidth, parentLeft + parentWidth) - intersectionLeft; // width\n\n  // check whether the element is visible in the intersection\n  var top = void 0;\n  var left = void 0;\n  var height = void 0;\n  var width = void 0;\n\n  try {\n    var _node$getBoundingClie = node.getBoundingClientRect();\n\n    top = _node$getBoundingClie.top;\n    left = _node$getBoundingClie.left;\n    height = _node$getBoundingClie.height;\n    width = _node$getBoundingClie.width;\n  } catch (e) {\n    top = defaultBoundingClientRect.top;\n    left = defaultBoundingClientRect.left;\n    height = defaultBoundingClientRect.height;\n    width = defaultBoundingClientRect.width;\n  }\n\n  var offsetTop = top - intersectionTop; // element's top relative to intersection\n  var offsetLeft = left - intersectionLeft; // element's left relative to intersection\n\n  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API\n\n  return offsetTop - offsets[0] <= intersectionHeight && offsetTop + height + offsets[1] >= 0 && offsetLeft - offsets[0] <= intersectionWidth && offsetLeft + width + offsets[1] >= 0;\n};\n\n/**\n * Check if `component` is visible in document\n * @param  {node} component React component\n * @return {bool}\n */\nvar checkNormalVisible = function checkNormalVisible(component) {\n  var node = _reactDom2.default.findDOMNode(component);\n\n  // If this element is hidden by css rules somehow, it's definitely invisible\n  if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false;\n\n  var top = void 0;\n  var elementHeight = void 0;\n\n  try {\n    var _node$getBoundingClie2 = node.getBoundingClientRect();\n\n    top = _node$getBoundingClie2.top;\n    elementHeight = _node$getBoundingClie2.height;\n  } catch (e) {\n    top = defaultBoundingClientRect.top;\n    elementHeight = defaultBoundingClientRect.height;\n  }\n\n  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;\n\n  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API\n\n  return top - offsets[0] <= windowInnerHeight && top + elementHeight + offsets[1] >= 0;\n};\n\n/**\n * Detect if element is visible in viewport, if so, set `visible` state to true.\n * If `once` prop is provided true, remove component as listener after checkVisible\n *\n * @param  {React} component   React component that respond to scroll and resize\n */\nvar checkVisible = function checkVisible(component) {\n  var node = _reactDom2.default.findDOMNode(component);\n  if (!(node instanceof HTMLElement)) {\n    return;\n  }\n\n  var parent = (0, _scrollParent2.default)(node);\n  var isOverflow = component.props.overflow && parent !== node.ownerDocument && parent !== document && parent !== document.documentElement;\n  var visible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component);\n  if (visible) {\n    // Avoid extra render if previously is visible\n    if (!component.visible) {\n      if (component.props.once) {\n        pending.push(component);\n      }\n\n      component.visible = true;\n      component.forceUpdate();\n    }\n  } else if (!(component.props.once && component.visible)) {\n    component.visible = false;\n    if (component.props.unmountIfInvisible) {\n      component.forceUpdate();\n    }\n  }\n};\n\nvar purgePending = function purgePending() {\n  pending.forEach(function (component) {\n    var index = listeners.indexOf(component);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  });\n\n  pending = [];\n};\n\nvar lazyLoadHandler = function lazyLoadHandler() {\n  for (var i = 0; i < listeners.length; ++i) {\n    var listener = listeners[i];\n    checkVisible(listener);\n  }\n  // Remove `once` component in listeners\n  purgePending();\n};\n\n// Depending on component's props\nvar delayType = void 0;\nvar finalLazyLoadHandler = null;\n\nvar isString = function isString(string) {\n  return typeof string === 'string';\n};\n\nvar LazyLoad = function (_Component) {\n  _inherits(LazyLoad, _Component);\n\n  function LazyLoad(props) {\n    _classCallCheck(this, LazyLoad);\n\n    var _this = _possibleConstructorReturn(this, (LazyLoad.__proto__ || Object.getPrototypeOf(LazyLoad)).call(this, props));\n\n    _this.visible = false;\n    return _this;\n  }\n\n  _createClass(LazyLoad, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // It's unlikely to change delay type on the fly, this is mainly\n      // designed for tests\n      var scrollport = window;\n      var scrollContainer = this.props.scrollContainer;\n\n      if (scrollContainer) {\n        if (isString(scrollContainer)) {\n          scrollport = scrollport.document.querySelector(scrollContainer);\n        }\n      }\n      var needResetFinalLazyLoadHandler = this.props.debounce !== undefined && delayType === 'throttle' || delayType === 'debounce' && this.props.debounce === undefined;\n\n      if (needResetFinalLazyLoadHandler) {\n        (0, _event.off)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);\n        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        finalLazyLoadHandler = null;\n      }\n\n      if (!finalLazyLoadHandler) {\n        if (this.props.debounce !== undefined) {\n          finalLazyLoadHandler = (0, _debounce2.default)(lazyLoadHandler, typeof this.props.debounce === 'number' ? this.props.debounce : 300);\n          delayType = 'debounce';\n        } else if (this.props.throttle !== undefined) {\n          finalLazyLoadHandler = (0, _throttle2.default)(lazyLoadHandler, typeof this.props.throttle === 'number' ? this.props.throttle : 300);\n          delayType = 'throttle';\n        } else {\n          finalLazyLoadHandler = lazyLoadHandler;\n        }\n      }\n\n      if (this.props.overflow) {\n        var parent = (0, _scrollParent2.default)(_reactDom2.default.findDOMNode(this));\n        if (parent && typeof parent.getAttribute === 'function') {\n          var listenerCount = 1 + +parent.getAttribute(LISTEN_FLAG);\n          if (listenerCount === 1) {\n            parent.addEventListener('scroll', finalLazyLoadHandler, passiveEvent);\n          }\n          parent.setAttribute(LISTEN_FLAG, listenerCount);\n        }\n      } else if (listeners.length === 0 || needResetFinalLazyLoadHandler) {\n        var _props = this.props,\n            scroll = _props.scroll,\n            resize = _props.resize;\n\n\n        if (scroll) {\n          (0, _event.on)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);\n        }\n\n        if (resize) {\n          (0, _event.on)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        }\n      }\n\n      listeners.push(this);\n      checkVisible(this);\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return this.visible;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.props.overflow) {\n        var parent = (0, _scrollParent2.default)(_reactDom2.default.findDOMNode(this));\n        if (parent && typeof parent.getAttribute === 'function') {\n          var listenerCount = +parent.getAttribute(LISTEN_FLAG) - 1;\n          if (listenerCount === 0) {\n            parent.removeEventListener('scroll', finalLazyLoadHandler, passiveEvent);\n            parent.removeAttribute(LISTEN_FLAG);\n          } else {\n            parent.setAttribute(LISTEN_FLAG, listenerCount);\n          }\n        }\n      }\n\n      var index = listeners.indexOf(this);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n\n      if (listeners.length === 0 && typeof window !== 'undefined') {\n        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        (0, _event.off)(window, 'scroll', finalLazyLoadHandler, passiveEvent);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return this.visible ? this.props.children : this.props.placeholder ? this.props.placeholder : _react2.default.createElement('div', { style: { height: this.props.height }, className: 'lazyload-placeholder' });\n    }\n  }]);\n\n  return LazyLoad;\n}(_react.Component);\n\nLazyLoad.propTypes = {\n  once: _propTypes2.default.bool,\n  height: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),\n  offset: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),\n  overflow: _propTypes2.default.bool,\n  resize: _propTypes2.default.bool,\n  scroll: _propTypes2.default.bool,\n  children: _propTypes2.default.node,\n  throttle: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),\n  debounce: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),\n  placeholder: _propTypes2.default.node,\n  scrollContainer: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  unmountIfInvisible: _propTypes2.default.bool\n};\n\nLazyLoad.defaultProps = {\n  once: false,\n  offset: 0,\n  overflow: false,\n  resize: false,\n  scroll: true,\n  unmountIfInvisible: false\n};\n\nvar getDisplayName = function getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n};\n\nvar decorator = function decorator() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function lazyload(WrappedComponent) {\n    return function (_Component2) {\n      _inherits(LazyLoadDecorated, _Component2);\n\n      function LazyLoadDecorated() {\n        _classCallCheck(this, LazyLoadDecorated);\n\n        var _this2 = _possibleConstructorReturn(this, (LazyLoadDecorated.__proto__ || Object.getPrototypeOf(LazyLoadDecorated)).call(this));\n\n        _this2.displayName = 'LazyLoad' + getDisplayName(WrappedComponent);\n        return _this2;\n      }\n\n      _createClass(LazyLoadDecorated, [{\n        key: 'render',\n        value: function render() {\n          return _react2.default.createElement(\n            LazyLoad,\n            options,\n            _react2.default.createElement(WrappedComponent, this.props)\n          );\n        }\n      }]);\n\n      return LazyLoadDecorated;\n    }(_react.Component);\n  };\n};\n\nexports.lazyload = decorator;\nexports.default = LazyLoad;\nexports.forceCheck = lazyLoadHandler;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\nfunction debounce(func, wait, immediate) {\n  var timeout = void 0;\n  var args = void 0;\n  var context = void 0;\n  var timestamp = void 0;\n  var result = void 0;\n\n  var later = function later() {\n    var last = +new Date() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = null;\n          args = null;\n        }\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = +new Date();\n\n    var callNow = immediate && !timeout;\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = null;\n      args = null;\n    }\n\n    return result;\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.on = on;\nexports.off = off;\nfunction on(el, eventName, callback, opts) {\n  opts = opts || false;\n  if (el.addEventListener) {\n    el.addEventListener(eventName, callback, opts);\n  } else if (el.attachEvent) {\n    el.attachEvent(\"on\" + eventName, function (e) {\n      callback.call(el, e || window.event);\n    });\n  }\n}\n\nfunction off(el, eventName, callback, opts) {\n  opts = opts || false;\n  if (el.removeEventListener) {\n    el.removeEventListener(eventName, callback, opts);\n  } else if (el.detachEvent) {\n    el.detachEvent(\"on\" + eventName, callback);\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * @fileOverview Find scroll parent\n */\n\nexports.default = function (node) {\n  if (!(node instanceof HTMLElement)) {\n    return document.documentElement;\n  }\n\n  var excludeStaticParent = node.style.position === 'absolute';\n  var overflowRegex = /(scroll|auto)/;\n  var parent = node;\n\n  while (parent) {\n    if (!parent.parentNode) {\n      return node.ownerDocument || document.documentElement;\n    }\n\n    var style = window.getComputedStyle(parent);\n    var position = style.position;\n    var overflow = style.overflow;\n    var overflowX = style['overflow-x'];\n    var overflowY = style['overflow-y'];\n\n    if (position === 'static' && excludeStaticParent) {\n      parent = parent.parentNode;\n      continue;\n    }\n\n    if (overflowRegex.test(overflow) && overflowRegex.test(overflowX) && overflowRegex.test(overflowY)) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return node.ownerDocument || node.documentElement || document.documentElement;\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = throttle;\n/*eslint-disable */\nfunction throttle(fn, threshhold, scope) {\n  threshhold || (threshhold = 250);\n  var last, deferTimer;\n  return function () {\n    var context = scope || this;\n\n    var now = +new Date(),\n        args = arguments;\n    if (last && now < last + threshhold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshhold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}","\"use strict\";\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;"],"names":[],"sourceRoot":""}