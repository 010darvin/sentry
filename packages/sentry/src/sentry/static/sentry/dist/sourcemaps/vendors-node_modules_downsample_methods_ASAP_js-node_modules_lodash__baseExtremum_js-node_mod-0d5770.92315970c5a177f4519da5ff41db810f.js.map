{"version":3,"file":"chunks/vendors-node_modules_downsample_methods_ASAP_js-node_modules_lodash__baseExtremum_js-node_mod-0d5770.xxxxxxxxxxxxxxxxxxxx.js","mappings":";;;;;;;;;AAAa;;AAEb,8CAA6C,EAAE,aAAa,EAAC;;AAE7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,+BAA+B;AAC7E;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,sBAAsB;AACtB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA,IAAI;;;AAGJ,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,qBAAqB,WAAW;AAChC;AACA;;AAEA,sBAAsB,SAAS;AAC/B,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;;AAEA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA,kBAAkB,OAAO;AACzB,6BAA6B;;AAE7B;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA,IAAI;;;AAGJ;AACA;AACA,6DAA6D;;AAE7D,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;;;AAGA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;;AAGA,+BAA+B;;AAE/B;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,kBAAkB;AAClB;;;;;;;;;;;ACvlBA,eAAe,mBAAO,CAAC,sDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA","sources":["webpack:///../node_modules/downsample/methods/ASAP.js","webpack:///../node_modules/lodash/_baseExtremum.js","webpack:///../node_modules/lodash/_baseGt.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar __isA = {\n  \"PointValueExtractor<unknown>\": value => typeof value === \"function\",\n  \"XYDataPoint\": value => value !== undefined && value !== null && __isA[\"X\"](value[\"x\"]) && typeof value[\"y\"] === \"number\",\n  \"X\": value => typeof value === \"number\" || value instanceof Date\n};\nvar calculateMean = values => {\n  var m = 0;\n\n  for (var i = 0; i < values.length; i += 1) {\n    m += values[i];\n  }\n\n  return m / values.length;\n};\nvar calculateSTD = values => {\n  var mean = calculateMean(values);\n  var std = 0;\n\n  for (var i = 0; i < values.length; i += 1) {\n    std += (values[i] - mean) * (values[i] - mean);\n  }\n\n  return Math.sqrt(std / values.length);\n};\nvar mapToArray = (input, callback) => {\n  var length = input.length;\n  var result = new Array(length);\n\n  for (var i = 0; i < length; i++) {\n    result[i] = callback(input[i], i);\n  }\n\n  return result;\n};\nvar getPointValueExtractor = accessor => {\n  if (__isA[\"PointValueExtractor<unknown>\"](accessor)) return accessor;\n  return point => point[accessor];\n};\nvar createXYDataPoint = (time, value) => ({\n  x: time,\n  y: value\n});\nvar createLegacyDataPointConfig = () => ({\n  x: point => {\n    var t = __isA[\"XYDataPoint\"](point) ? point.x : point[0];\n    return t instanceof Date ? t.getTime() : t;\n  },\n  y: point => 'y' in point ? point.y : point[1],\n  toPoint: createXYDataPoint\n});\nvar iterableBasedOn = (input, length) => new input.constructor(length);\n\nvar SMANumeric = function SMANumeric(data, windowSize) {\n  var slide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var output = [];\n  var sum = 0;\n\n  for (var i = 0; i < windowSize; i++) {\n    sum += data[i];\n  }\n\n  for (var _i = windowSize; _i <= data.length; _i++) {\n    if ((_i - windowSize) % slide === 0) {\n      output.push(sum / windowSize);\n    }\n\n    sum += data[_i] - data[_i - windowSize];\n  }\n\n  return output;\n};\n/**\n * Simple Moving Average (SMA)\n *\n * @param data {Number[]}\n * @param windowSize {Number}\n * @param slide {Number}\n */\n\nvar createSMA = config => {\n  var timeExtractor = getPointValueExtractor(config.x);\n  var valueExtractor = getPointValueExtractor(config.y);\n  var pointFactory = config.toPoint;\n  return function (values, windowSize) {\n    var slide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    if (values.length === 0) return values;\n    var data = mapToArray(values, valueExtractor);\n    var times = mapToArray(values, timeExtractor);\n    var output = iterableBasedOn(values, 0);\n    var sum = 0;\n    var value;\n\n    for (var i = 0; i < windowSize; i++) {\n      sum += data[i];\n    }\n\n    for (var _i2 = windowSize; _i2 <= data.length; _i2++) {\n      if ((_i2 - windowSize) % slide === 0) {\n        value = pointFactory((times[_i2 - windowSize] + times[_i2 - 1]) / 2, sum / windowSize, _i2 - windowSize);\n        output[output.length] = value;\n      }\n\n      sum += data[_i2] - data[_i2 - windowSize];\n    }\n\n    return output;\n  };\n};\nvar SMA = createSMA(createLegacyDataPointConfig());\n\n/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2014 Project Nayuki\n * https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * (MIT License)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function.\n */\n\nfunction fft(real, imag) {\n  if (real.length != imag.length) throw 'Mismatched lengths';\n  var n = real.length;\n  if (n == 0) return;else if ((n & n - 1) == 0) // Is power of 2\n    transformRadix2(real, imag); // More complicated algorithm for arbitrary sizes\n  else transformBluestein(real, imag);\n}\n/*\n * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n */\n\nfunction inverseFFT(real, imag) {\n  fft(imag, real);\n}\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n */\n\nfunction transformRadix2(real, imag) {\n  // Initialization\n  if (real.length != imag.length) throw 'Mismatched lengths';\n  var n = real.length;\n  if (n == 1) // Trivial transform\n    return;\n  var levels = -1;\n\n  for (var i = 0; i < 32; i++) {\n    if (1 << i == n) levels = i; // Equal to log2(n)\n  }\n\n  if (levels == -1) throw 'Length is not a power of 2';\n  var cosTable = new Array(n / 2);\n  var sinTable = new Array(n / 2);\n\n  for (var _i = 0; _i < n / 2; _i++) {\n    cosTable[_i] = Math.cos(2 * Math.PI * _i / n);\n    sinTable[_i] = Math.sin(2 * Math.PI * _i / n);\n  } // Bit-reversed addressing permutation\n\n\n  for (var _i2 = 0; _i2 < n; _i2++) {\n    var j = reverseBits(_i2, levels);\n\n    if (j > _i2) {\n      var temp = real[_i2];\n      real[_i2] = real[j];\n      real[j] = temp;\n      temp = imag[_i2];\n      imag[_i2] = imag[j];\n      imag[j] = temp;\n    }\n  } // Cooley-Tukey decimation-in-time radix-2 FFT\n\n\n  for (var size = 2; size <= n; size *= 2) {\n    var halfsize = size / 2;\n    var tablestep = n / size;\n\n    for (var _i3 = 0; _i3 < n; _i3 += size) {\n      for (var _j = _i3, k = 0; _j < _i3 + halfsize; _j++, k += tablestep) {\n        var tpre = real[_j + halfsize] * cosTable[k] + imag[_j + halfsize] * sinTable[k];\n        var tpim = -real[_j + halfsize] * sinTable[k] + imag[_j + halfsize] * cosTable[k];\n        real[_j + halfsize] = real[_j] - tpre;\n        imag[_j + halfsize] = imag[_j] - tpim;\n        real[_j] += tpre;\n        imag[_j] += tpim;\n      }\n    }\n  }\n} // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n\n\nfunction reverseBits(x, bits) {\n  var y = 0;\n\n  for (var i = 0; i < bits; i++) {\n    y = y << 1 | x & 1;\n    x >>>= 1;\n  }\n\n  return y;\n}\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.\n * Uses Bluestein's chirp z-transform algorithm.\n */\n\n\nfunction transformBluestein(real, imag) {\n  // Find a power-of-2 convolution length m such that m >= n * 2 + 1\n  if (real.length != imag.length) throw 'Mismatched lengths';\n  var n = real.length;\n  var m = 1;\n\n  while (m < n * 2 + 1) {\n    m *= 2;\n  } // Trignometric tables\n\n\n  var cosTable = new Array(n);\n  var sinTable = new Array(n);\n\n  for (var i = 0; i < n; i++) {\n    var j = i * i % (n * 2); // This is more accurate than j = i * i\n\n    cosTable[i] = Math.cos(Math.PI * j / n);\n    sinTable[i] = Math.sin(Math.PI * j / n);\n  } // Temporary vectors and preprocessing\n\n\n  var areal = new Array(m);\n  var aimag = new Array(m);\n\n  for (var _i4 = 0; _i4 < n; _i4++) {\n    areal[_i4] = real[_i4] * cosTable[_i4] + imag[_i4] * sinTable[_i4];\n    aimag[_i4] = -real[_i4] * sinTable[_i4] + imag[_i4] * cosTable[_i4];\n  }\n\n  for (var _i5 = n; _i5 < m; _i5++) {\n    areal[_i5] = aimag[_i5] = 0;\n  }\n\n  var breal = new Array(m);\n  var bimag = new Array(m);\n  breal[0] = cosTable[0];\n  bimag[0] = sinTable[0];\n\n  for (var _i6 = 1; _i6 < n; _i6++) {\n    breal[_i6] = breal[m - _i6] = cosTable[_i6];\n    bimag[_i6] = bimag[m - _i6] = sinTable[_i6];\n  }\n\n  for (var _i7 = n; _i7 <= m - n; _i7++) {\n    breal[_i7] = bimag[_i7] = 0;\n  } // Convolution\n\n\n  var creal = new Array(m);\n  var cimag = new Array(m);\n  convolveComplex(areal, aimag, breal, bimag, creal, cimag); // Postprocessing\n\n  for (var _i8 = 0; _i8 < n; _i8++) {\n    real[_i8] = creal[_i8] * cosTable[_i8] + cimag[_i8] * sinTable[_i8];\n    imag[_i8] = -creal[_i8] * sinTable[_i8] + cimag[_i8] * cosTable[_i8];\n  }\n}\n/*\n * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.\n */\n\n\nfunction convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag) {\n  if (xreal.length != ximag.length || xreal.length != yreal.length || yreal.length != yimag.length || xreal.length != outreal.length || outreal.length != outimag.length) throw 'Mismatched lengths';\n  var n = xreal.length;\n  xreal = xreal.slice();\n  ximag = ximag.slice();\n  yreal = yreal.slice();\n  yimag = yimag.slice();\n  fft(xreal, ximag);\n  fft(yreal, yimag);\n\n  for (var i = 0; i < n; i++) {\n    var temp = xreal[i] * yreal[i] - ximag[i] * yimag[i];\n    ximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];\n    xreal[i] = temp;\n  }\n\n  inverseFFT(xreal, ximag);\n\n  for (var _i9 = 0; _i9 < n; _i9++) {\n    // Scaling (because this FFT implementation omits it)\n    outreal[_i9] = xreal[_i9] / n;\n    outimag[_i9] = ximag[_i9] / n;\n  }\n}\n\nvar calculateDiffs = values => {\n  var length = values.length - 1;\n  if (length < 1) return [];\n  var diffs = new Array(length);\n\n  for (var i = 0; i < length; i++) {\n    diffs[i] = values[i + 1] - values[i];\n  }\n\n  return diffs;\n};\n\nvar calculateRoughness = values => calculateSTD(calculateDiffs(values));\n\nvar calculateKurtosis = values => {\n  var length = values.length;\n  var mean = calculateMean(values);\n  var u4 = 0;\n  var variance = 0;\n  var diff;\n  var diffSqr;\n\n  for (var i = 0; i < length; i++) {\n    diff = values[i] - mean;\n    diffSqr = diff * diff;\n    u4 += diffSqr * diffSqr;\n    variance += diffSqr;\n  }\n\n  return length * u4 / (variance * variance);\n};\n\nvar findWindowSize = (head, tail, data, minRoughness, originalKurt, windowSize) => {\n  while (head <= tail) {\n    var w = Math.round((head + tail) / 2);\n    var smoothed = SMANumeric(data, w, 1);\n    var kurtosis = calculateKurtosis(smoothed);\n\n    if (kurtosis >= originalKurt) {\n      /* Search second half if feasible */\n      var roughness = calculateRoughness(smoothed);\n\n      if (roughness < minRoughness) {\n        windowSize = w;\n        minRoughness = roughness;\n      }\n\n      head = w + 1;\n    } else {\n      /* Search first half */\n      tail = w - 1;\n    }\n  }\n\n  return windowSize;\n};\n\nvar calculatePeaks = function calculatePeaks(correlations) {\n  var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.2;\n  var length = correlations.length;\n  if (length <= 1) return [[], 0];\n  var maxCorrelation = 0;\n  var peaks = [];\n\n  if (correlations.length > 1) {\n    var positive = correlations[1] > correlations[0];\n    var max = 1;\n\n    for (var i = 2; i < correlations.length; i += 1) {\n      if (!positive && correlations[i] > correlations[i - 1]) {\n        max = i;\n        positive = !positive;\n      } else if (positive && correlations[i] > correlations[max]) {\n        max = i;\n      } else if (positive && correlations[i] < correlations[i - 1]) {\n        if (max > 1 && correlations[max] > threshold) {\n          peaks.push(max);\n\n          if (correlations[max] > maxCorrelation) {\n            maxCorrelation = correlations[max];\n          }\n        }\n\n        positive = !positive;\n      }\n    }\n  }\n  /* If there is no autocorrelation peak within the MAX_WINDOW boundary try windows from the largest to the smallest */\n\n\n  if (peaks.length <= 1) {\n    for (var _i = 2; _i < length; _i += 1) {\n      peaks.push(_i);\n    }\n  }\n\n  return [peaks, maxCorrelation];\n};\n\nvar calculateAutocorrelation = (values, maxLag) => {\n  var length = values.length;\n  var mean = calculateMean(values);\n  /* Padding to the closest power of 2 */\n\n  var len = Math.pow(2, Math.trunc(Math.log2(length)) + 1);\n  var fftreal = new Array(len).fill(0);\n  var fftimg = new Array(len).fill(0);\n\n  for (var i = 0; i < length; i += 1) {\n    fftreal[i] = values[i] - mean;\n  }\n  /* F_R(f) = FFT(X) */\n\n\n  fft(fftreal, fftimg);\n  /* S(f) = F_R(f)F_R*(f) */\n\n  for (var _i2 = 0; _i2 < fftreal.length; _i2 += 1) {\n    fftreal[_i2] = Math.pow(fftreal[_i2], 2) + Math.pow(fftimg[_i2], 2);\n    fftimg[_i2] = 0;\n  }\n  /*  R(t) = IFFT(S(f)) */\n\n\n  inverseFFT(fftreal, fftimg); // Calculate correlations\n\n  var correlations = [];\n\n  for (var _i3 = 1; _i3 < maxLag; _i3++) {\n    correlations[_i3] = fftreal[_i3] / fftreal[0];\n  }\n\n  var _calculatePeaks = calculatePeaks(correlations),\n      _calculatePeaks2 = _slicedToArray(_calculatePeaks, 2),\n      peaks = _calculatePeaks2[0],\n      maxCorrelation = _calculatePeaks2[1];\n\n  return {\n    correlations,\n    peaks,\n    maxCorrelation\n  };\n};\n\nvar createASAP = config => {\n  var valueExtractor = getPointValueExtractor(config.y);\n  var SMA = createSMA(config);\n  return function ASAP(values, resolution) {\n    if (values.length === 0) return values;\n\n    if (resolution <= 0) {\n      throw new Error(\"Supplied non-positive resolution parameter to ASAP: \".concat(resolution));\n    } // If the resolution is at least twice as big as the number of data points\n    // then the values get downsampled to desired resolution first by SMA\n\n\n    if (values.length >= 2 * resolution) {\n      var scale = Math.trunc(values.length / resolution);\n      return ASAP(SMA(values, scale, scale), resolution);\n    } // First turn data points into a sequence of values\n\n\n    var data = mapToArray(values, valueExtractor);\n\n    var _calculateAutocorrela = calculateAutocorrelation(data, Math.round(data.length / 10)),\n        correlations = _calculateAutocorrela.correlations,\n        peaks = _calculateAutocorrela.peaks,\n        maxCorrelation = _calculateAutocorrela.maxCorrelation;\n\n    var originalKurtosis = calculateKurtosis(data);\n    var minRoughness = calculateRoughness(data);\n    var windowSize = 1;\n    var lb = 1;\n    var largestFeasible = -1;\n    var tail = data.length / 10;\n\n    for (var i = peaks.length - 1; i >= 0; i -= 1) {\n      var w = peaks[i];\n\n      if (w < lb || w === 1) {\n        break;\n      } else if (Math.sqrt(1 - correlations[w]) * windowSize > Math.sqrt(1 - correlations[windowSize]) * w) {\n        continue;\n      }\n\n      var smoothed = SMANumeric(data, w, 1);\n      var kurtosis = calculateKurtosis(smoothed);\n      var roughness = calculateRoughness(smoothed);\n\n      if (kurtosis >= originalKurtosis) {\n        if (roughness < minRoughness) {\n          minRoughness = roughness;\n          windowSize = w;\n        }\n\n        lb = Math.round(Math.max(w * Math.sqrt((maxCorrelation - 1) / (correlations[w] - 1)), lb));\n\n        if (largestFeasible < 0) {\n          largestFeasible = i;\n        }\n      }\n    }\n\n    if (largestFeasible > 0) {\n      if (largestFeasible < peaks.length - 2) {\n        tail = peaks[largestFeasible + 1];\n      }\n\n      lb = Math.max(lb, peaks[largestFeasible] + 1);\n    }\n\n    windowSize = findWindowSize(lb, tail, data, minRoughness, originalKurtosis, windowSize);\n    return SMA(values, windowSize, 1);\n  };\n};\nvar ASAP = createASAP(createLegacyDataPointConfig());\n\nexports.ASAP = ASAP;\nexports.createASAP = createASAP;\n//# sourceMappingURL=ASAP.js.map\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n"],"names":[],"sourceRoot":""}