{"version":3,"file":"chunks/app_components_profiling_profileHeader_tsx-app_views_profiling_profileGroupProvider_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/profiling/breadcrumb.tsx","webpack:///./app/components/profiling/profileHeader.tsx","webpack:///./app/utils/profiling/callTreeNode.tsx","webpack:///./app/utils/profiling/formatters/stackMarkerToHumanReadable.tsx","webpack:///./app/utils/profiling/frame.tsx","webpack:///./app/utils/profiling/guards/profile.tsx","webpack:///./app/utils/profiling/jsSelfProfiling.tsx","webpack:///./app/utils/profiling/profile/chromeTraceProfile.tsx","webpack:///./app/utils/profiling/profile/eventedProfile.tsx","webpack:///./app/utils/profiling/profile/importProfile.tsx","webpack:///./app/utils/profiling/profile/jsSelfProfile.tsx","webpack:///./app/utils/profiling/profile/profile.tsx","webpack:///./app/utils/profiling/profile/sampledProfile.tsx","webpack:///./app/utils/profiling/profile/utils.tsx","webpack:///./app/utils/profiling/routes.tsx","webpack:///./app/utils/profiling/weightedNode.tsx","webpack:///./app/utils/useLocation.tsx","webpack:///./app/utils/useParams.tsx","webpack:///./app/views/profiling/profileGroupProvider.tsx"],"sourcesContent":["import {useMemo} from 'react';\nimport styled from '@emotion/styled';\nimport {Location} from 'history';\n\nimport Breadcrumbs, {Crumb} from 'sentry/components/breadcrumbs';\nimport {t} from 'sentry/locale';\nimport {Organization, Project} from 'sentry/types';\nimport {\n  generateProfileDetailsRouteWithQuery,\n  generateProfileFlamechartRouteWithQuery,\n  generateProfileSummaryRouteWithQuery,\n  generateProfilingRouteWithQuery,\n} from 'sentry/utils/profiling/routes';\n\ninterface BreadcrumbProps {\n  location: Location;\n  organization: Organization;\n  trails: Trail[];\n}\n\nfunction Breadcrumb({location, organization, trails}: BreadcrumbProps) {\n  const crumbs = useMemo(\n    () => trails.map(trail => trailToCrumb(trail, {location, organization})),\n    [location, organization, trails]\n  );\n  return <StyledBreadcrumbs crumbs={crumbs} />;\n}\n\nfunction trailToCrumb(\n  trail: Trail,\n  {\n    location,\n    organization,\n  }: {\n    location: Location;\n    organization: Organization;\n  }\n): Crumb {\n  switch (trail.type) {\n    case 'landing': {\n      return {\n        to: generateProfilingRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n        }),\n        label: t('Profiling'),\n        preservePageFilters: true,\n      };\n    }\n    case 'profile summary': {\n      return {\n        to: generateProfileSummaryRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n          projectSlug: trail.payload.projectSlug,\n          transaction: trail.payload.transaction,\n        }),\n        label: t('Profile Summary'),\n        preservePageFilters: true,\n      };\n    }\n    case 'flamechart': {\n      const generateRouteWithQuery =\n        trail.payload.tab === 'flamechart'\n          ? generateProfileFlamechartRouteWithQuery\n          : generateProfileDetailsRouteWithQuery;\n      return {\n        to: generateRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n          projectSlug: trail.payload.projectSlug,\n          profileId: trail.payload.profileId,\n        }),\n        label: trail.payload.transaction,\n        preservePageFilters: true,\n      };\n    }\n    default:\n      throw new Error(`Unknown breadcrumb type: ${JSON.stringify(trail)}`);\n  }\n}\n\ntype ProfilingTrail = {\n  type: 'landing';\n};\n\ntype ProfileSummaryTrail = {\n  payload: {\n    projectSlug: Project['slug'];\n    transaction: string;\n  };\n  type: 'profile summary';\n};\n\ntype FlamegraphTrail = {\n  payload: {\n    profileId: string;\n    projectSlug: string;\n    tab: 'flamechart' | 'details';\n    transaction: string;\n  };\n  type: 'flamechart';\n};\n\ntype Trail = ProfilingTrail | ProfileSummaryTrail | FlamegraphTrail;\n\nconst StyledBreadcrumbs = styled(Breadcrumbs)`\n  padding: 0;\n`;\n\nexport {Breadcrumb};\n","import {Link} from 'react-router';\n\nimport * as Layout from 'sentry/components/layouts/thirds';\nimport {Breadcrumb} from 'sentry/components/profiling/breadcrumb';\nimport {t} from 'sentry/locale';\nimport {\n  generateProfileDetailsRouteWithQuery,\n  generateProfileFlamechartRouteWithQuery,\n} from 'sentry/utils/profiling/routes';\nimport {useLocation} from 'sentry/utils/useLocation';\nimport useOrganization from 'sentry/utils/useOrganization';\nimport {useParams} from 'sentry/utils/useParams';\nimport {useProfileGroup} from 'sentry/views/profiling/profileGroupProvider';\n\nfunction ProfileHeader() {\n  const params = useParams();\n  const location = useLocation();\n  const organization = useOrganization();\n  const [profileGroup] = useProfileGroup();\n\n  const transaction = profileGroup.type === 'resolved' ? profileGroup.data.name : '';\n  const profileId = params.eventId ?? '';\n  const projectSlug = params.projectId ?? '';\n\n  return (\n    <Layout.Header style={{gridTemplateColumns: 'minmax(0, 1fr)'}}>\n      <Layout.HeaderContent style={{marginBottom: 0}}>\n        <Breadcrumb\n          location={location}\n          organization={organization}\n          trails={[\n            {type: 'landing'},\n            {\n              type: 'profile summary',\n              payload: {\n                projectSlug,\n                transaction,\n              },\n            },\n            {\n              type: 'flamechart',\n              payload: {\n                transaction,\n                profileId,\n                projectSlug,\n                tab: location.pathname.endsWith('details/') ? 'details' : 'flamechart',\n              },\n            },\n          ]}\n        />\n      </Layout.HeaderContent>\n      <Layout.HeaderNavTabs underlined>\n        <li className={location.pathname.endsWith('flamechart/') ? 'active' : undefined}>\n          <Link\n            to={generateProfileFlamechartRouteWithQuery({\n              orgSlug: organization.slug,\n              projectSlug,\n              profileId,\n              location,\n            })}\n          >\n            {t('Flamechart')}\n          </Link>\n        </li>\n        <li className={location.pathname.endsWith('details/') ? 'active' : undefined}>\n          <Link\n            to={generateProfileDetailsRouteWithQuery({\n              orgSlug: organization.slug,\n              projectSlug,\n              profileId,\n              location,\n            })}\n          >\n            {t('Details')}\n          </Link>\n        </li>\n      </Layout.HeaderNavTabs>\n    </Layout.Header>\n  );\n}\n\nexport {ProfileHeader};\n","import {Frame} from './frame';\nimport {WeightedNode} from './weightedNode';\n\nexport class CallTreeNode extends WeightedNode {\n  readonly frame: Frame;\n\n  private locked = false;\n\n  parent: CallTreeNode | null;\n  recursive: CallTreeNode | null;\n  children: CallTreeNode[] = [];\n\n  constructor(frame: Frame, parent: CallTreeNode | null) {\n    super();\n    this.recursive = null;\n    this.parent = parent;\n    this.frame = frame;\n  }\n\n  setParent(parent: CallTreeNode): void {\n    this.parent = parent;\n  }\n\n  setRecursiveThroughNode(node: CallTreeNode): void {\n    this.recursive = node;\n  }\n\n  isRecursive(): boolean {\n    return !!this.recursive;\n  }\n\n  isDirectRecursive(): boolean {\n    if (!this.parent) {\n      return false;\n    }\n    return this.parent.frame === this.frame;\n  }\n\n  isLocked(): boolean {\n    return this.locked;\n  }\n\n  lock(): void {\n    this.locked = true;\n  }\n\n  isRoot(): boolean {\n    return Frame.Root.name === this.frame.name;\n  }\n\n  static readonly Root = new CallTreeNode(Frame.Root, null);\n}\n","import {t} from 'sentry/locale';\n\n// This is the formatter for the stack marker spec https://github.com/WICG/js-self-profiling/blob/main/markers.md\nexport function stackMarkerToHumanReadable(marker: JSSelfProfiling.Marker): string {\n  switch (marker) {\n    case 'gc':\n      return t('Garbage Collection');\n    case 'style':\n      return t('Style');\n    case 'layout':\n      return t('Layout');\n    case 'paint':\n      return t('Paint');\n    case 'script':\n      return t('Script');\n    case 'other':\n      return t('Other');\n    default:\n      // since spec is still in dev, just gracefully return whatever we received.\n      return marker;\n  }\n}\n","import {t} from 'sentry/locale';\n\nimport {WeightedNode} from './weightedNode';\n\nexport class Frame extends WeightedNode {\n  readonly key: string | number;\n  readonly name: string;\n  readonly file?: string;\n  readonly line?: number;\n  readonly column?: number;\n  readonly is_application: boolean;\n  readonly image?: string;\n  readonly resource?: string;\n  readonly threadId?: number;\n\n  static Root = new Frame(\n    {\n      key: 'sentry root',\n      name: 'sentry root',\n      is_application: false,\n    },\n    'mobile'\n  );\n\n  constructor(frameInfo: Profiling.FrameInfo, type?: 'mobile' | 'web') {\n    super();\n\n    this.key = frameInfo.key;\n    this.file = frameInfo.file;\n    this.name = frameInfo.name;\n    this.resource = frameInfo.resource;\n    this.line = frameInfo.line;\n    this.column = frameInfo.column;\n    this.is_application =\n      type === 'web'\n        ? frameInfo.line === undefined && frameInfo.column === undefined\n        : !!frameInfo.is_application;\n    this.image = frameInfo.image;\n    this.threadId = frameInfo.threadId;\n\n    if (type === 'web') {\n      // If the frame is a web frame and there is no name associated to it, then it was likely invoked as an iife or anonymous callback as\n      // most modern browser engines properly show anonymous functions when they are assigned to references (e.g. `let foo = function() {};`)\n      if (!frameInfo.name) {\n        this.name = t('anonymous');\n      }\n      // If the frame had no line or column, it was part of the native code, (e.g. calling String.fromCharCode)\n      if (frameInfo.line === undefined && frameInfo.column === undefined) {\n        this.name += ` ${t('[native code]')}`;\n      }\n    }\n  }\n\n  isRoot(): boolean {\n    return this.name === Frame.Root.name;\n  }\n}\n","export function isSchema(input: any): input is Profiling.Schema {\n  return (\n    typeof input === 'object' &&\n    'transactionName' in input &&\n    'profiles' in input &&\n    Array.isArray(input.profiles) &&\n    'shared' in input\n  );\n}\nexport function isEventedProfile(profile: any): profile is Profiling.EventedProfile {\n  return 'type' in profile && profile.type === 'evented';\n}\n\nexport function isSampledProfile(profile: any): profile is Profiling.SampledProfile {\n  return 'type' in profile && profile.type === 'sampled';\n}\n\nexport function isJSProfile(profile: any): profile is JSSelfProfiling.Trace {\n  return !('type' in profile) && Array.isArray(profile.resources);\n}\n\nexport function isChromeTraceObjectFormat(input: any): input is ChromeTrace.ObjectFormat {\n  return typeof input === 'object' && 'traceEvents' in input;\n}\n\n// We check for the presence of at least one ProfileChunk event in the trace\nexport function isChromeTraceArrayFormat(input: any): input is ChromeTrace.ProfileType {\n  return (\n    Array.isArray(input) && input.some(p => p.ph === 'P' && p.name === 'ProfileChunk')\n  );\n}\n\n// Typescript uses only a subset of the event types (only B and E cat),\n// so we need to inspect the contents of the trace to determine the type of the profile.\n// The TS trace can still contain other event types like metadata events, meaning we cannot\n// use array.every() and need to check all the events to make sure no P events are present\nexport function isTypescriptChromeTraceArrayFormat(\n  input: any\n): input is ChromeTrace.ArrayFormat {\n  return (\n    Array.isArray(input) && !input.some(p => p.ph === 'P' && p.name === 'ProfileChunk')\n  );\n}\n\nexport function isChromeTraceFormat(input: any): input is ChromeTrace.ArrayFormat {\n  return (\n    isTypescriptChromeTraceArrayFormat(input) ||\n    isChromeTraceObjectFormat(input) ||\n    isChromeTraceArrayFormat(input)\n  );\n}\n","import {stackMarkerToHumanReadable} from './formatters/stackMarkerToHumanReadable';\nimport {Frame} from './frame';\n\nfunction createMarkerFrame(marker: JSSelfProfiling.Marker): JSSelfProfiling.Frame {\n  return {\n    name: stackMarkerToHumanReadable(marker),\n    resourceId: undefined,\n    line: undefined,\n    column: undefined,\n  };\n}\n/**\n * Utility fn to resolve stack frames starting from the top most frame.\n * Each frame points to it's parent, with the initial stackId pointer pointing to the top of the frame.\n * We walk down the stack until no more frames are found, appending the parent frame to the list.\n * As a result we end up with a list of frames starting from the root most frame.\n *\n * There is a caching opportunity here, as stackId's point to the same parts of the stack, resolving it once is sufficient\n * and all subsequent calls could be cached. Some instrumentation and testing would be required, leaving as is for now.\n */\nexport function resolveJSSelfProfilingStack(\n  trace: JSSelfProfiling.Trace,\n  stackId: JSSelfProfiling.Sample['stackId'],\n  frameIndex: Record<number, Frame>,\n  marker?: JSSelfProfiling.Marker\n): Frame[] {\n  // If there is no stack associated with a sample, it means the thread was idle\n  const callStack: Frame[] = [];\n\n  // There can only be one marker per callStack, so prepend it to the start of the stack\n  if (marker && marker !== 'script') {\n    callStack.unshift(new Frame({...createMarkerFrame(marker), key: marker}));\n  }\n\n  if (stackId === undefined) {\n    return callStack;\n  }\n\n  let stack: JSSelfProfiling.Stack | undefined = trace.stacks[stackId];\n\n  // If the stackId cannot be resolved from the stacks dict, it means the format is corrupt or partial (possibly due to termination reasons).\n  // This should never happen, but in the offchance that it somehow does, it should be handled.\n  if (!stack) {\n    throw new Error(`Missing stackId ${stackId} in trace, cannot resolve stack`);\n  }\n\n  while (stack !== undefined) {\n    // If the frameId pointer cannot be resolved, it means the format is corrupt or partial (possibly due to termination reasons).\n    // This should never happen, but in the offchance that it somehow does, it should be handled.\n    if (trace.frames[stack.frameId] === undefined) {\n      return callStack;\n    }\n\n    callStack.unshift(frameIndex[stack.frameId]);\n\n    if (stack.parentId !== undefined) {\n      stack = trace.stacks[stack.parentId];\n    } else {\n      stack = undefined;\n    }\n  }\n\n  return callStack;\n}\n","/**\n * The import code is very similar to speedscope's import code. The queue approach works well and allows us\n * to easily split the X events and handle them. There are some small differences when it comes to building\n * profiles where we opted to throw instead of closing a frame that was never opened.\n *\n * Overall, it seems that mostly typescript compiler uses this output, so we could possibly do a bit more\n * in order to detect if this is a tsc trace and mark the different compiler phases and give users the preference\n * to color encode by the program/bind/check/emit phases.\n */\nimport {Frame} from 'sentry/utils/profiling/frame';\nimport {Profile} from 'sentry/utils/profiling/profile/profile';\nimport {wrapWithSpan} from 'sentry/utils/profiling/profile/utils';\n\nimport {EventedProfile} from './eventedProfile';\nimport {ImportOptions, ProfileGroup} from './importProfile';\n\nexport class ChromeTraceProfile extends EventedProfile {}\n\ntype ProcessId = number;\ntype ThreadId = number;\n\nexport function splitEventsByProcessAndTraceId(\n  trace: ChromeTrace.ArrayFormat\n): Map<ProcessId, Map<ThreadId, ChromeTrace.Event[]>> {\n  const collections: Map<ProcessId, Map<ThreadId, ChromeTrace.Event[]>> = new Map();\n\n  for (let i = 0; i < trace.length; i++) {\n    const event = trace[i];\n\n    if (typeof event.pid !== 'number') {\n      continue;\n    }\n    if (typeof event.tid !== 'number') {\n      continue;\n    }\n\n    let processes = collections.get(event.pid);\n    if (!processes) {\n      processes = new Map();\n      collections.set(event.pid, processes);\n    }\n\n    let threads = processes.get(event.tid);\n    if (!threads) {\n      threads = [];\n      processes.set(event.tid, threads);\n    }\n\n    threads.push(event);\n  }\n\n  return collections;\n}\n\nfunction chronologicalSort(a: ChromeTrace.Event, b: ChromeTrace.Event): number {\n  return a.ts - b.ts;\n}\n\nfunction reverseChronologicalSort(a: ChromeTrace.Event, b: ChromeTrace.Event): number {\n  return b.ts - a.ts;\n}\n\nfunction getNextQueue(\n  beginQueue: ChromeTrace.Event[],\n  endQueue: ChromeTrace.Event[]\n): 'B' | 'E' {\n  if (!beginQueue.length && !endQueue.length) {\n    throw new Error('Profile contains no events');\n  }\n\n  const nextBegin = beginQueue[beginQueue.length - 1];\n  const nextEnd = endQueue[endQueue.length - 1];\n\n  if (!nextEnd) {\n    return 'B';\n  }\n  if (!nextBegin) {\n    return 'E';\n  }\n  if (nextBegin.ts < nextEnd.ts) {\n    return 'B';\n  }\n  if (nextEnd.ts < nextBegin.ts) {\n    return 'E';\n  }\n  return 'B';\n}\n\nfunction buildProfile(\n  processId: number,\n  threadId: number,\n  events: ChromeTrace.Event[]\n): ChromeTraceProfile {\n  let processName: string = `pid (${processId})`;\n  let threadName: string = `tid (${threadId})`;\n\n  // We dont care about other events besides begin, end, instant events and metadata events\n  const timelineEvents = events.filter(\n    e => e.ph === 'B' || e.ph === 'E' || e.ph === 'X' || e.ph === 'M'\n  );\n\n  const beginQueue: Array<ChromeTrace.Event> = [];\n  const endQueue: Array<ChromeTrace.Event> = [];\n\n  for (let i = 0; i < timelineEvents.length; i++) {\n    const event = timelineEvents[i];\n\n    // M events are not pushed to the queue, we just store their information\n    if (event.ph === 'M') {\n      if (event.name === 'thread_name' && typeof event.args.name === 'string') {\n        threadName = `${event.args.name} (${threadId})`;\n        continue;\n      }\n\n      if (event.name === 'process_name' && typeof event.args.name === 'string') {\n        processName = `${event.args.name} (${processId})`;\n        continue;\n      }\n    }\n\n    // B, E and X events are pushed to the timeline. We transform all X events into\n    // B and E event, so that they can be pushed onto the queue and handled\n    if (event.ph === 'B') {\n      beginQueue.push(event);\n      continue;\n    }\n\n    if (event.ph === 'E') {\n      endQueue.push(event);\n      continue;\n    }\n\n    if (event.ph === 'X') {\n      if (typeof event.dur === 'number' || typeof event.tdur === 'number') {\n        beginQueue.push({...event, ph: 'B'});\n        endQueue.push({...event, ph: 'E', ts: event.ts + (event.dur ?? event.tdur ?? 0)});\n        continue;\n      }\n    }\n  }\n\n  beginQueue.sort(reverseChronologicalSort);\n  endQueue.sort(reverseChronologicalSort);\n\n  if (!beginQueue.length) {\n    throw new Error('Profile does not contain any frame events');\n  }\n\n  const firstTimestamp = beginQueue[beginQueue.length - 1].ts;\n  const lastTimestamp = endQueue[0]?.ts ?? beginQueue[0].ts;\n\n  if (typeof firstTimestamp !== 'number') {\n    throw new Error('First begin event contains no timestamp');\n  }\n\n  if (typeof lastTimestamp !== 'number') {\n    throw new Error('Last end event contains no timestamp');\n  }\n\n  const profile = new ChromeTraceProfile(\n    lastTimestamp - firstTimestamp,\n    firstTimestamp,\n    lastTimestamp,\n    `${processName}: ${threadName}`,\n    'microseconds', // the trace event format provides timestamps in microseconds\n    threadId\n  );\n\n  const stack: ChromeTrace.Event[] = [];\n  const frameCache = new Map<string, Frame>();\n\n  while (beginQueue.length > 0 || endQueue.length > 0) {\n    const next = getNextQueue(beginQueue, endQueue);\n\n    if (next === 'B') {\n      const item = beginQueue.pop();\n      if (!item) {\n        throw new Error('Nothing to take from begin queue');\n      }\n\n      const frameInfo = createFrameInfoFromEvent(item);\n\n      if (!frameCache.has(frameInfo.key)) {\n        frameCache.set(frameInfo.key, new Frame(frameInfo));\n      }\n\n      const frame = frameCache.get(frameInfo.key)!;\n      profile.enterFrame(frame, item.ts - firstTimestamp);\n      stack.push(item);\n      continue;\n    }\n\n    if (next === 'E') {\n      const item = endQueue.pop()!;\n      let frameInfo = createFrameInfoFromEvent(item);\n\n      if (stack[stack.length - 1] === undefined) {\n        throw new Error(\n          `Unable to close frame from an empty stack, attempting to close ${JSON.stringify(\n            item\n          )}`\n        );\n      }\n      const topFrameInfo = createFrameInfoFromEvent(stack[stack.length - 1]);\n\n      // We check frames with the same ts and look for a match. We do this because\n      // chronological sort will not break ties on frames that end at the same time,\n      // but may not be in the same order as they were opened.\n      for (let i = endQueue.length - 2; i > 0; i--) {\n        if (endQueue[i].ts > endQueue[endQueue.length - 1].ts) {\n          break;\n        }\n\n        const nextEndInfo = createFrameInfoFromEvent(endQueue[i]);\n        if (topFrameInfo.key === nextEndInfo.key) {\n          const tmp = endQueue[endQueue.length - 1];\n          endQueue[endQueue.length - 1] = endQueue[i];\n          endQueue[i] = tmp;\n\n          frameInfo = nextEndInfo;\n          break;\n        }\n      }\n\n      if (!frameCache.has(frameInfo.key)) {\n        throw new Error(\n          `Cannot leave frame that was never entered, leaving ${frameInfo.key}`\n        );\n      }\n\n      const frame = frameCache.get(frameInfo.key)!;\n      profile.leaveFrame(frame, item.ts - firstTimestamp);\n      stack.pop();\n      continue;\n    }\n  }\n\n  // Close the leftover frames in stack\n  while (stack.length) {\n    const item = stack.pop()!;\n    const frameInfo = createFrameInfoFromEvent(item);\n\n    const frame = frameCache.get(frameInfo.key);\n    if (!frame) {\n      throw new Error(\n        `Cannot leave frame that was never entered, leaving ${frameInfo.key}`\n      );\n    }\n    profile.leaveFrame(frame, frame.totalWeight);\n  }\n\n  return profile.build();\n}\n\nfunction createFrameInfoFromEvent(event: ChromeTrace.Event) {\n  const key = JSON.stringify(event.args);\n\n  return {\n    key,\n    name: `${event?.name || 'Unknown'} ${key}`.trim(),\n  };\n}\n\nexport function parseTypescriptChromeTraceArrayFormat(\n  input: ChromeTrace.ArrayFormat,\n  traceID: string,\n  options?: ImportOptions\n): ProfileGroup {\n  const profiles: Profile[] = [];\n  const eventsByProcessAndThreadID = splitEventsByProcessAndTraceId(input);\n\n  for (const [processId, threads] of eventsByProcessAndThreadID) {\n    for (const [threadId, events] of threads) {\n      wrapWithSpan(\n        options?.transaction,\n        () => profiles.push(buildProfile(processId, threadId, events ?? [])),\n        {\n          op: 'profile.import',\n          description: 'chrometrace',\n        }\n      );\n    }\n  }\n\n  return {\n    name: 'chrometrace',\n    traceID,\n    activeProfileIndex: 0,\n    profiles,\n  };\n}\n\nfunction isProfileEvent(event: ChromeTrace.Event): event is ChromeTrace.ProfileEvent {\n  return event.ph === 'P' && event.name === 'Profile';\n}\n\nfunction isProfileChunk(\n  event: ChromeTrace.Event\n): event is ChromeTrace.ProfileChunkEvent {\n  return event.ph === 'P' && event.name === 'ProfileChunk';\n}\n\nfunction isThreadmetaData(\n  event: ChromeTrace.Event\n): event is ChromeTrace.ThreadMetadataEvent {\n  event.name === 'Thread';\n\n  return event.ph === 'M' && event.name === 'Thread';\n}\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// This mostly follows what speedscope does for the Chrome Trace format, but we do minor adjustments (not sure if they are correct atm),\n// but the protocol format seems out of date and is not well documented, so this is a best effort.\nfunction collectEventsByProfile(input: ChromeTrace.ArrayFormat): {\n  cpuProfiles: Map<string, Required<ChromeTrace.CpuProfile>>;\n  threadNames: Map<string, string>;\n} {\n  const sorted = input.sort(chronologicalSort);\n\n  const threadNames = new Map<string, string>();\n  const profileIdToProcessAndThreadIds = new Map<string, [number, number]>();\n  const cpuProfiles = new Map<string, Required<ChromeTrace.CpuProfile>>();\n\n  for (let i = 0; i < sorted.length; i++) {\n    const event = sorted[i];\n\n    if (isThreadmetaData(event)) {\n      threadNames.set(`${event.pid}:${event.tid}`, event.args.name);\n      continue;\n    }\n\n    // A profile entry will happen before we see any ProfileChunks, so the order here matters\n    if (isProfileEvent(event)) {\n      profileIdToProcessAndThreadIds.set(event.id, [event.pid, event.tid]);\n\n      if (cpuProfiles.has(event.id)) {\n        continue;\n      }\n\n      // Judging by https://github.com/v8/v8/blob/b8626ca445554b8376b5a01f651b70cb8c01b7dd/src/inspector/js_protocol.json#L1453,\n      // the only optional properties of a profile event are the samples and the timeDelta, however looking at a few sample traces\n      // this does not seem to be the case. For example, in our chrometrace/trace.json there is a profile entry where only startTime is present\n      cpuProfiles.set(event.id, {\n        samples: [],\n        timeDeltas: [],\n        // @ts-ignore\n        startTime: 0,\n        // @ts-ignore\n        endTime: 0,\n        // @ts-ignore\n        nodes: [],\n        ...event.args.data,\n      });\n      continue;\n    }\n\n    if (isProfileChunk(event)) {\n      const profile = cpuProfiles.get(event.id);\n\n      if (!profile) {\n        throw new Error('No entry for Profile was found before ProfileChunk');\n      }\n\n      // If we have a chunk, then append our values to it. Eventually we end up with a single profile with all of the chunks and samples merged\n      const cpuProfile = event.args.data.cpuProfile;\n      if (cpuProfile.nodes) {\n        profile.nodes = profile.nodes.concat(cpuProfile.nodes ?? []);\n      }\n      if (cpuProfile.samples) {\n        profile.samples = profile.samples.concat(cpuProfile.samples ?? []);\n      }\n      if (cpuProfile.timeDeltas) {\n        profile.timeDeltas = profile.timeDeltas.concat(cpuProfile.timeDeltas ?? []);\n      }\n      if (cpuProfile.startTime !== null) {\n        // Make sure we dont overwrite the startTime if it is already set\n        if (typeof profile.startTime === 'number') {\n          profile.startTime = Math.min(profile.startTime, cpuProfile.startTime);\n        } else {\n          profile.startTime = cpuProfile.startTime;\n        }\n      }\n      // Make sure we dont overwrite the endTime if it is already set\n      if (cpuProfile.endTime !== null) {\n        if (typeof profile.endTime === 'number') {\n          profile.endTime = Math.max(profile.endTime, cpuProfile.endTime);\n        } else {\n          profile.endTime = cpuProfile.endTime;\n        }\n      }\n    }\n    continue;\n  }\n\n  return {cpuProfiles, threadNames};\n}\n\nfunction createFramesIndex(\n  profile: ChromeTrace.CpuProfile\n): Map<number, ChromeTrace.ProfileNode> {\n  const frames: Map<number, ChromeTrace.ProfileNode> = new Map();\n\n  for (let i = 0; i < profile.nodes.length; i++) {\n    frames.set(profile.nodes[i].id, {...profile.nodes[i]});\n  }\n\n  for (let i = 0; i < profile.nodes.length; i++) {\n    const profileNode = profile.nodes[i];\n\n    if (typeof profileNode.parent === 'number') {\n      const parent = frames.get(profileNode.parent);\n\n      if (parent === undefined) {\n        throw new Error('Missing frame parent in profile');\n      }\n    }\n\n    if (!profileNode.children) {\n      continue;\n    }\n\n    for (let j = 0; j < profileNode.children.length; j++) {\n      const child = frames.get(profileNode.children[j]);\n\n      if (child === undefined) {\n        throw new Error('Missing frame child in profile');\n      }\n\n      child.parent = profileNode;\n    }\n  }\n\n  return frames;\n}\n\n// Cpu profiles can often contain a lot of sequential samples that point to the same stack.\n// It's wasteful to process these one by one, we can instead collapse them and just update the time delta.\n// We should consider a similar approach for the backend sample storage. I expect we will remove\n// this code from the frontend once we have backend support and a unified format for these.\n// Effectively, samples like [1,1,2,1] and timedeltas [1,2,1,1] to sample [1,2,1] and timedeltas [3,1,1]\nexport function collapseSamples(profile: ChromeTrace.CpuProfile): {\n  sampleTimes: number[];\n  samples: number[];\n} {\n  const samples: number[] = [];\n  const sampleTimes: number[] = [];\n\n  // If we have no samples, then we can't collapse anything\n  if (!profile.samples || !profile.samples.length) {\n    throw new Error('Profile is missing samples');\n  }\n\n  // If we have no time deltas then the format may be corrupt\n  if (!profile.timeDeltas || !profile.timeDeltas.length) {\n    throw new Error('Profile is missing timeDeltas');\n  }\n\n  // If timedeltas does not match samples, then the format may be corrupt\n  if (profile.timeDeltas.length !== profile.samples.length) {\n    throw new Error(\"Profile's samples and timeDeltas don't match\");\n  }\n\n  if (profile.samples.length === 1 && profile.timeDeltas.length === 1) {\n    return {samples: [profile.samples[0]], sampleTimes: [profile.timeDeltas[0]]};\n  }\n\n  // First delta is relative to profile start\n  // https://github.com/v8/v8/blob/44bd8fd7/src/inspector/js_protocol.json#L1485\n  let elapsed: number = profile.timeDeltas[0];\n\n  // This is quite significantly changed from speedscope's implementation.\n  // We iterate over all samples and check if we can collapse them or not.\n  // A sample should be collapsed when there are more that 2 consecutive samples\n  // that are pointing to the same stack.\n  for (let i = 0; i < profile.samples.length; i++) {\n    const nodeId = profile.samples[i];\n\n    // Initialize the delta to 0, so we can accumulate the deltas of any collapsed samples\n    let delta = 0;\n    // Start at i\n    let j = i;\n    // While we are not at the end and next sample is the same as current\n    while (j < profile.samples.length && profile.samples[j + 1] === nodeId) {\n      // Update the delta and advance j. In some cases, v8 reports deltas\n      // as negative. We will just ignore these deltas and make sure that\n      // we never go back in time when updating the delta.\n      delta = Math.max(delta + profile.timeDeltas[j + 1], delta);\n      j++;\n    }\n\n    // Check if we skipped more than 1 element\n    if (j - i > 1) {\n      // We skipped more than 1 element, so we should collapse the samples,\n      // push the first element where we started with the elapsed time\n      // and last element where we started with the elapsed time + delta\n      samples.push(nodeId);\n      sampleTimes.push(elapsed);\n      samples.push(nodeId);\n      sampleTimes.push(elapsed + delta);\n      elapsed += delta;\n      i = j;\n    } else {\n      // If we have not skipped samples, then we just push the sample and the delta to the list\n      samples.push(nodeId);\n      sampleTimes.push(elapsed);\n\n      // In some cases, v8 reports deltas as negative. We will just ignore\n      // these deltas and make sure that we never go back in time when updating the delta.\n      elapsed = Math.max(elapsed + profile.timeDeltas[i + 1], elapsed);\n    }\n  }\n  return {samples, sampleTimes};\n}\n\nexport function parseChromeTraceFormat(\n  input: ChromeTrace.ArrayFormat,\n  traceID: string,\n  _options?: ImportOptions\n): ProfileGroup {\n  const {cpuProfiles, threadNames: _threadNames} = collectEventsByProfile(input);\n\n  for (const [_profileId, profile] of cpuProfiles.entries()) {\n    // @ts-ignore\n    // eslint-disable-next-line\n    const index = createFramesIndex(profile);\n    const {samples: _samples, sampleTimes: _sampleTimes} = collapseSamples(profile);\n  }\n\n  return {\n    name: 'chrometrace',\n    traceID,\n    activeProfileIndex: 0,\n    profiles: [],\n  };\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\nexport class EventedProfile extends Profile {\n  appendOrderStack: CallTreeNode[] = [this.appendOrderTree];\n  stack: Frame[] = [];\n\n  lastValue = 0;\n\n  static FromProfile(\n    eventedProfile: Profiling.EventedProfile,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): EventedProfile {\n    const profile = new EventedProfile(\n      eventedProfile.endValue - eventedProfile.startValue,\n      eventedProfile.startValue,\n      eventedProfile.endValue,\n      eventedProfile.name,\n      eventedProfile.unit,\n      eventedProfile.threadID\n    );\n\n    // If frames are offset, we need to set lastValue to profile start, so that delta between\n    // samples is correctly offset by the start value.\n    profile.lastValue = Math.max(0, eventedProfile.startValue);\n\n    for (const event of eventedProfile.events) {\n      const frame = frameIndex[event.frame];\n\n      if (!frame) {\n        throw new Error(`Cannot retrieve event: ${event.frame} from frame index`);\n      }\n\n      switch (event.type) {\n        // Open a new frame\n        case 'O': {\n          profile.enterFrame(frame, event.at);\n          break;\n        }\n        // Close a frame\n        case 'C': {\n          profile.leaveFrame(frame, event.at);\n          break;\n        }\n        default: {\n          throw new TypeError(`Unknown event type ${event.type}`);\n        }\n      }\n    }\n\n    return profile.build();\n  }\n\n  addWeightToFrames(weight: number): void {\n    const weightDelta = weight - this.lastValue;\n\n    for (const frame of this.stack) {\n      frame.addToTotalWeight(weightDelta);\n    }\n\n    const top = lastOfArray(this.stack);\n    if (top) {\n      top.addToSelfWeight(weight);\n    }\n  }\n\n  addWeightsToNodes(value: number) {\n    const delta = value - this.lastValue;\n\n    for (const node of this.appendOrderStack) {\n      node.addToTotalWeight(delta);\n    }\n    const stackTop = lastOfArray(this.appendOrderStack);\n\n    if (stackTop) {\n      stackTop.addToSelfWeight(delta);\n    }\n  }\n\n  enterFrame(frame: Frame, at: number): void {\n    this.addWeightToFrames(at);\n    this.addWeightsToNodes(at);\n\n    const lastTop = lastOfArray(this.appendOrderStack);\n\n    if (lastTop) {\n      const sampleDelta = at - this.lastValue;\n\n      if (sampleDelta < 0) {\n        throw new Error(\n          'Sample delta cannot be negative, samples may be corrupt or out of order'\n        );\n      }\n\n      // If the sample timestamp is not the same as the same as of previous frame,\n      // we can deduce that this is a new sample and need to push it on the stack\n      if (sampleDelta > 0) {\n        this.samples.push(lastTop);\n        this.weights.push(sampleDelta);\n      }\n\n      const last = lastOfArray(lastTop.children);\n      let node: CallTreeNode;\n\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        node = new CallTreeNode(frame, lastTop);\n        lastTop.children.push(node);\n      }\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack with their respective indexes\n      // We check the stack in a top-down order to find the first recursive frame.\n      let start = this.appendOrderStack.length - 1;\n      while (start >= 0) {\n        if (this.appendOrderStack[start].frame === node.frame) {\n          // The recursion edge is bidirectional\n          this.appendOrderStack[start].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(this.appendOrderStack[start]);\n          break;\n        }\n        start--;\n      }\n\n      this.appendOrderStack.push(node);\n    }\n\n    this.stack.push(frame);\n    this.lastValue = at;\n  }\n\n  leaveFrame(_event: Frame, at: number): void {\n    this.addWeightToFrames(at);\n    this.addWeightsToNodes(at);\n    this.trackSampleStats(at);\n\n    const leavingStackTop = this.appendOrderStack.pop();\n\n    if (leavingStackTop === undefined) {\n      throw new Error('Unbalanced stack');\n    }\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    leavingStackTop.lock();\n    const sampleDelta = at - this.lastValue;\n\n    if (sampleDelta > 0) {\n      this.samples.push(leavingStackTop);\n      this.weights.push(sampleDelta);\n      // Keep track of the minFrameDuration\n      this.minFrameDuration = Math.min(sampleDelta, this.minFrameDuration);\n    }\n\n    this.stack.pop();\n    this.lastValue = at;\n  }\n\n  build(): EventedProfile {\n    if (this.appendOrderStack.length > 1) {\n      throw new Error('Unbalanced append order stack');\n    }\n\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import * as Sentry from '@sentry/react';\nimport {Transaction} from '@sentry/types';\n\nimport {\n  isChromeTraceFormat,\n  isChromeTraceObjectFormat,\n  isEventedProfile,\n  isJSProfile,\n  isSampledProfile,\n  isSchema,\n  isTypescriptChromeTraceArrayFormat,\n} from '../guards/profile';\n\nimport {parseTypescriptChromeTraceArrayFormat} from './chromeTraceProfile';\nimport {EventedProfile} from './eventedProfile';\nimport {JSSelfProfile} from './jsSelfProfile';\nimport {Profile} from './profile';\nimport {SampledProfile} from './sampledProfile';\nimport {createFrameIndex, wrapWithSpan} from './utils';\n\nexport interface ImportOptions {\n  transaction: Transaction | undefined;\n}\n\nexport interface ProfileGroup {\n  activeProfileIndex: number;\n  name: string;\n  profiles: Profile[];\n  traceID: string;\n}\n\nexport function importProfile(\n  input: Profiling.Schema | JSSelfProfiling.Trace | ChromeTrace.ProfileType,\n  traceID: string\n): ProfileGroup {\n  const transaction = Sentry.startTransaction({\n    op: 'import',\n    name: 'profiles.import',\n  });\n\n  try {\n    if (isJSProfile(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'js-self-profile');\n      }\n      return importJSSelfProfile(input, traceID, {transaction});\n    }\n\n    if (isChromeTraceFormat(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'chrometrace');\n      }\n      return importChromeTrace(input, traceID, {transaction});\n    }\n\n    if (isSchema(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'schema');\n      }\n      return importSchema(input, traceID, {transaction});\n    }\n\n    throw new Error('Unsupported trace format');\n  } catch (error) {\n    if (transaction) {\n      transaction.setStatus('internal_error');\n    }\n    throw error;\n  } finally {\n    if (transaction) {\n      transaction.finish();\n    }\n  }\n}\n\nfunction importJSSelfProfile(\n  input: JSSelfProfiling.Trace,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  const frameIndex = createFrameIndex(input.frames);\n\n  return {\n    traceID,\n    name: traceID,\n    activeProfileIndex: 0,\n    profiles: [importSingleProfile(input, frameIndex, options)],\n  };\n}\n\nfunction importChromeTrace(\n  input: ChromeTrace.ProfileType,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  if (isChromeTraceObjectFormat(input)) {\n    throw new Error('Chrometrace object format is not yet supported');\n  }\n\n  if (isTypescriptChromeTraceArrayFormat(input)) {\n    return parseTypescriptChromeTraceArrayFormat(input, traceID, options);\n  }\n\n  throw new Error('Failed to parse trace input format');\n}\n\nfunction importSchema(\n  input: Profiling.Schema,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  const frameIndex = createFrameIndex(input.shared.frames);\n\n  return {\n    traceID,\n    name: input.transactionName,\n    activeProfileIndex: input.activeProfileIndex ?? 0,\n    profiles: input.profiles.map(profile =>\n      importSingleProfile(profile, frameIndex, options)\n    ),\n  };\n}\n\nfunction importSingleProfile(\n  profile: Profiling.ProfileTypes,\n  frameIndex: ReturnType<typeof createFrameIndex>,\n  {transaction}: ImportOptions\n): Profile {\n  if (isEventedProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return EventedProfile.FromProfile(profile, frameIndex);\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => EventedProfile.FromProfile(profile, frameIndex),\n      {\n        op: 'profile.import',\n        description: 'evented',\n      }\n    );\n  }\n  if (isSampledProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return SampledProfile.FromProfile(profile, frameIndex);\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => SampledProfile.FromProfile(profile, frameIndex),\n      {\n        op: 'profile.import',\n        description: 'sampled',\n      }\n    );\n  }\n  if (isJSProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return JSSelfProfile.FromProfile(profile, createFrameIndex(profile.frames));\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => JSSelfProfile.FromProfile(profile, createFrameIndex(profile.frames)),\n      {\n        op: 'profile.import',\n        description: 'js-self-profile',\n      }\n    );\n  }\n  throw new Error('Unrecognized trace format');\n}\n\nconst tryParseInputString: JSONParser = input => {\n  try {\n    return [JSON.parse(input), null];\n  } catch (e) {\n    return [null, e];\n  }\n};\n\ntype JSONParser = (input: string) => [any, null] | [null, Error];\n\nconst TRACE_JSON_PARSERS: ((string) => ReturnType<JSONParser>)[] = [\n  (input: string) => tryParseInputString(input),\n  (input: string) => tryParseInputString(input + ']'),\n];\n\nfunction readFileAsString(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.addEventListener('load', (e: ProgressEvent<FileReader>) => {\n      if (typeof e.target?.result === 'string') {\n        resolve(e.target.result);\n        return;\n      }\n\n      reject('Failed to read string contents of input file');\n    });\n\n    reader.addEventListener('error', () => {\n      reject('Failed to read string contents of input file');\n    });\n\n    reader.readAsText(file);\n  });\n}\n\nexport async function importDroppedProfile(\n  file: File,\n  parsers: JSONParser[] = TRACE_JSON_PARSERS\n): Promise<ProfileGroup> {\n  const fileContents = await readFileAsString(file);\n\n  for (const parser of parsers) {\n    const [json] = parser(fileContents);\n\n    if (json) {\n      if (typeof json !== 'object' || json === null) {\n        throw new TypeError('Input JSON is not an object');\n      }\n\n      return importProfile(json, file.name);\n    }\n  }\n\n  throw new Error('Failed to parse input JSON');\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {stackMarkerToHumanReadable} from './../formatters/stackMarkerToHumanReadable';\nimport {resolveJSSelfProfilingStack} from './../jsSelfProfiling';\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\nexport class JSSelfProfile extends Profile {\n  static FromProfile(\n    profile: JSSelfProfiling.Trace,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): JSSelfProfile {\n    // In the case of JSSelfProfiling, we need to index the abstract marker frames\n    // as they will otherwise not be present in the ProfilerStack.\n    const markers: JSSelfProfiling.Marker[] = [\n      'gc',\n      'layout',\n      'other',\n      'paint',\n      'script',\n      'style',\n    ];\n\n    for (const marker of markers) {\n      frameIndex[marker] = new Frame(\n        {\n          key: marker,\n          name: stackMarkerToHumanReadable(marker),\n          line: undefined,\n          column: undefined,\n          is_application: false,\n        },\n        'web'\n      );\n    }\n\n    const startedAt = profile.samples[0].timestamp;\n    const endedAt = lastOfArray(profile.samples).timestamp;\n\n    const jsSelfProfile = new JSSelfProfile(\n      endedAt - startedAt,\n      startedAt,\n      endedAt,\n      'JSSelfProfiling',\n      'milliseconds',\n      0\n    );\n\n    // Because JS self profiling takes an initial sample when we call new Profiler(),\n    // it means that the first sample weight will always be zero. We want to append the sample with 0 weight,\n    //  because the 2nd sample may part of the first sample's stack. This way we keep the most information we can of the stack trace\n    jsSelfProfile.appendSample(\n      resolveJSSelfProfilingStack(\n        profile,\n        profile.samples[0].stackId,\n        frameIndex,\n        profile.samples[0].marker\n      ),\n      0\n    );\n\n    // We start at stack 1, because we've already appended stack 0 above. The weight of each sample is the\n    // difference between the current sample and the previous one.\n    for (let i = 1; i < profile.samples.length; i++) {\n      // When gc is triggered, the stack may be indicated as empty. In that case, the thread was not idle\n      // and we should append gc to the top of the previous stack.\n      // https://github.com/WICG/js-self-profiling/issues/59\n      if (profile.samples[i].marker === 'gc') {\n        jsSelfProfile.appendSample(\n          resolveJSSelfProfilingStack(\n            profile,\n            // use the previous sample\n            profile.samples[i - 1].stackId,\n            frameIndex,\n            profile.samples[i].marker\n          ),\n          profile.samples[i].timestamp - profile.samples[i - 1].timestamp\n        );\n      } else {\n        jsSelfProfile.appendSample(\n          resolveJSSelfProfilingStack(\n            profile,\n            profile.samples[i].stackId,\n            frameIndex,\n            profile.samples[i].marker\n          ),\n          profile.samples[i].timestamp - profile.samples[i - 1].timestamp\n        );\n      }\n    }\n\n    return jsSelfProfile.build();\n  }\n\n  appendSample(stack: Frame[], weight: number): void {\n    this.trackSampleStats(weight);\n\n    let node = this.appendOrderTree;\n    const framesInStack: CallTreeNode[] = [];\n\n    for (const frame of stack) {\n      const last = lastOfArray(node.children);\n\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        const parent = node;\n        node = new CallTreeNode(frame, node);\n        parent.children.push(node);\n      }\n\n      node.addToTotalWeight(weight);\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack\n      // We check the stack in a top-down order to find the first recursive frame.\n      let stackHeight = framesInStack.length - 1;\n\n      while (stackHeight >= 0) {\n        if (framesInStack[stackHeight].frame === node.frame) {\n          // The recursion edge is bidirectional\n          framesInStack[stackHeight].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(framesInStack[stackHeight]);\n          break;\n        }\n        stackHeight--;\n      }\n\n      framesInStack.push(node);\n    }\n\n    node.addToSelfWeight(weight);\n\n    if (weight > 0) {\n      this.minFrameDuration = Math.min(weight, this.minFrameDuration);\n    }\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    for (const child of node.children) {\n      child.lock();\n    }\n\n    node.frame.addToSelfWeight(weight);\n\n    for (const stackNode of framesInStack) {\n      stackNode.frame.addToTotalWeight(weight);\n    }\n\n    // If node is the same as the previous sample, add the weight to the previous sample\n    if (node === lastOfArray(this.samples)) {\n      this.weights[this.weights.length - 1] += weight;\n    } else {\n      this.samples.push(node);\n      this.weights.push(weight);\n    }\n  }\n\n  build(): JSSelfProfile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import {lastOfArray} from 'sentry/utils';\n\nimport {CallTreeNode} from '../callTreeNode';\nimport {Frame} from '../frame';\n\ninterface ProfileStats {\n  discardedSamplesCount: number;\n  negativeSamplesCount: number;\n}\n\n// This is a simplified port of speedscope's profile with a few simplifications and some removed functionality + some added functionality.\n// head at commit e37f6fa7c38c110205e22081560b99cb89ce885e\n\n// We should try and remove these as we adopt our own profile format and only rely on the sampled format.\nexport class Profile {\n  // Duration of the profile\n  duration: number;\n  // Started at ts of the profile - varies between implementations of the profiler.\n  // For JS self profiles, this is the time origin (https://www.w3.org/TR/hr-time-2/#dfn-time-origin), for others it's epoch time\n  startedAt: number;\n  // Ended at ts of the profile - varies between implementations of the profiler.\n  // For JS self profiles, this is the time origin (https://www.w3.org/TR/hr-time-2/#dfn-time-origin), for others it's epoch time\n  endedAt: number;\n  threadId: number;\n\n  // Unit in which the timings are reported in\n  unit = 'microseconds';\n  // Name of the profile\n  name = 'Unknown';\n\n  appendOrderTree: CallTreeNode = new CallTreeNode(Frame.Root, null);\n  framesInStack: Set<Profiling.Event['frame']> = new Set();\n\n  // Min duration of the profile\n  minFrameDuration = Number.POSITIVE_INFINITY;\n\n  samples: CallTreeNode[] = [];\n  weights: number[] = [];\n\n  stats: ProfileStats = {\n    discardedSamplesCount: 0,\n    negativeSamplesCount: 0,\n  };\n\n  constructor(\n    duration: number,\n    startedAt: number,\n    endedAt: number,\n    name: string,\n    unit: string,\n    threadId: number\n  ) {\n    this.threadId = threadId;\n    this.duration = duration;\n    this.startedAt = startedAt;\n    this.endedAt = endedAt;\n    this.name = name;\n    this.unit = unit;\n  }\n\n  static Empty() {\n    return new Profile(1000, 0, 1000, '', 'milliseconds', 0).build();\n  }\n\n  trackSampleStats(duration: number) {\n    // Keep track of discarded samples and ones that may have negative weights\n    if (duration === 0) {\n      this.stats.discardedSamplesCount++;\n    }\n    if (duration < 0) {\n      this.stats.negativeSamplesCount++;\n    }\n  }\n\n  forEach(\n    openFrame: (node: CallTreeNode, value: number) => void,\n    closeFrame: (node: CallTreeNode, value: number) => void\n  ): void {\n    let prevStack: CallTreeNode[] = [];\n    let value = 0;\n\n    let sampleIndex = 0;\n\n    for (const stackTop of this.samples) {\n      let top: CallTreeNode | null = stackTop;\n\n      while (top && !top.isRoot() && prevStack.indexOf(top) === -1) {\n        top = top.parent;\n      }\n\n      while (prevStack.length > 0 && lastOfArray(prevStack) !== top) {\n        const node = prevStack.pop()!;\n        closeFrame(node, value);\n      }\n\n      const toOpen: CallTreeNode[] = [];\n\n      let node: CallTreeNode | null = stackTop;\n\n      while (node && !node.isRoot() && node !== top) {\n        toOpen.unshift(node);\n        node = node.parent;\n      }\n\n      for (const toOpenNode of toOpen) {\n        openFrame(toOpenNode, value);\n      }\n\n      prevStack = prevStack.concat(toOpen);\n      value += this.weights[sampleIndex++];\n    }\n\n    for (let i = prevStack.length - 1; i >= 0; i--) {\n      closeFrame(prevStack[i], value);\n    }\n  }\n\n  build(): Profile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\n\nimport {Frame} from './../frame';\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\n// This is a simplified port of speedscope's profile with a few simplifications and some removed functionality.\n// head at commit e37f6fa7c38c110205e22081560b99cb89ce885e\n\n// We should try and remove these as we adopt our own profile format and only rely on the sampled format.\nexport class SampledProfile extends Profile {\n  static FromProfile(\n    sampledProfile: Profiling.SampledProfile,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): Profile {\n    const profile = new SampledProfile(\n      sampledProfile.endValue - sampledProfile.startValue,\n      sampledProfile.startValue,\n      sampledProfile.endValue,\n      sampledProfile.name,\n      sampledProfile.unit,\n      sampledProfile.threadID\n    );\n\n    if (sampledProfile.samples.length !== sampledProfile.weights.length) {\n      throw new Error(\n        `Expected samples.length (${sampledProfile.samples.length}) to equal weights.length (${sampledProfile.weights.length})`\n      );\n    }\n\n    for (let i = 0; i < sampledProfile.samples.length; i++) {\n      const stack = sampledProfile.samples[i];\n      const weight = sampledProfile.weights[i];\n\n      profile.appendSampleWithWeight(\n        stack.map(n => {\n          if (!frameIndex[n]) {\n            throw new Error(`Could not resolve frame ${n} in frame index`);\n          }\n\n          return frameIndex[n];\n        }),\n        weight\n      );\n    }\n\n    return profile.build();\n  }\n\n  appendSampleWithWeight(stack: Frame[], weight: number): void {\n    // Keep track of discarded samples and ones that may have negative weights\n    this.trackSampleStats(weight);\n\n    // Ignore samples with 0 weight\n    if (weight === 0) {\n      return;\n    }\n\n    let node = this.appendOrderTree;\n    const framesInStack: CallTreeNode[] = [];\n\n    for (const frame of stack) {\n      const last = lastOfArray(node.children);\n      // Find common frame between two stacks\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        const parent = node;\n        node = new CallTreeNode(frame, node);\n        parent.children.push(node);\n      }\n\n      node.addToTotalWeight(weight);\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack\n      // We check the stack in a top-down order to find the first recursive frame.\n      let start = framesInStack.length - 1;\n      while (start >= 0) {\n        if (framesInStack[start].frame === node.frame) {\n          // The recursion edge is bidirectional\n          framesInStack[start].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(framesInStack[start]);\n          break;\n        }\n        start--;\n      }\n\n      framesInStack.push(node);\n    }\n\n    node.addToSelfWeight(weight);\n    this.minFrameDuration = Math.min(weight, this.minFrameDuration);\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    for (const child of node.children) {\n      child.lock();\n    }\n\n    node.frame.addToSelfWeight(weight);\n\n    for (const stackNode of framesInStack) {\n      stackNode.frame.addToTotalWeight(weight);\n    }\n\n    // If node is the same as the previous sample, add the weight to the previous sample\n    if (node === lastOfArray(this.samples)) {\n      this.weights[this.weights.length - 1] += weight;\n    } else {\n      this.samples.push(node);\n      this.weights.push(weight);\n    }\n  }\n\n  build(): Profile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import {Span} from '@sentry/types';\n\nimport {defined} from 'sentry/utils';\nimport {FlamegraphFrame} from 'sentry/utils/profiling/flamegraphFrame';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {CallTreeNode} from '../callTreeNode';\n\ntype FrameIndex = Record<string | number, Frame>;\n\nexport function createFrameIndex(\n  frames: Profiling.Schema['shared']['frames']\n): FrameIndex;\nexport function createFrameIndex(\n  frames: JSSelfProfiling.Frame[],\n  trace: JSSelfProfiling.Trace\n): FrameIndex;\nexport function createFrameIndex(\n  frames: Profiling.Schema['shared']['frames'] | JSSelfProfiling.Frame[],\n  trace?: JSSelfProfiling.Trace\n): FrameIndex {\n  if (trace) {\n    return (frames as JSSelfProfiling.Frame[]).reduce((acc, frame, index) => {\n      acc[index] = new Frame(\n        {\n          key: index,\n          resource:\n            frame.resourceId !== undefined\n              ? trace.resources[frame.resourceId]\n              : undefined,\n          ...frame,\n        },\n        'web'\n      );\n      return acc;\n    }, {});\n  }\n\n  return (frames as Profiling.Schema['shared']['frames']).reduce((acc, frame, index) => {\n    acc[index] = new Frame({\n      key: index,\n      ...frame,\n    });\n    return acc;\n  }, {});\n}\n\ntype Cache<Arguments extends ReadonlyArray<any> | any, Value> = {\n  args: Arguments;\n  value: Value;\n};\n\nexport function memoizeByReference<Arguments, Value>(\n  fn: (args: Arguments) => Value\n): (t: Arguments) => Value {\n  let cache: Cache<Arguments, Value> | null = null;\n\n  return function memoizeByReferenceCallback(args: Arguments) {\n    // If this is the first run then eval the fn and cache the result\n    if (!cache) {\n      cache = {args, value: fn(args)};\n      return cache.value;\n    }\n    // If args match by reference, then return cached value\n    if (cache.args === args && cache.args !== undefined && args !== undefined) {\n      return cache.value;\n    }\n\n    // Else eval the fn and store the new value\n    cache.args = args;\n    cache.value = fn(args);\n    return cache.value;\n  };\n}\n\nexport function memoizeVariadicByReference<Arguments, Value>(\n  fn: (...args: ReadonlyArray<Arguments>) => Value\n): (...t: ReadonlyArray<Arguments>) => Value {\n  let cache: Cache<ReadonlyArray<Arguments>, Value> | null = null;\n\n  return function memoizeByReferenceCallback(...args: ReadonlyArray<Arguments>) {\n    // If this is the first run then eval the fn and cache the result\n    if (!cache) {\n      cache = {args, value: fn(...args)};\n      return cache.value;\n    }\n    // If args match by reference, then return cached value\n    if (\n      cache.args.length === args.length &&\n      cache.args.length !== 0 &&\n      args.length !== 0 &&\n      args.every((arg, i) => arg === cache?.args[i])\n    ) {\n      return cache.value;\n    }\n\n    // Else eval the fn and store the new value\n    cache.args = args;\n    cache.value = fn(...args);\n    return cache.value;\n  };\n}\n\nexport function wrapWithSpan<T>(parentSpan: Span | undefined, fn: () => T, options): T {\n  if (!defined(parentSpan)) {\n    return fn();\n  }\n\n  const sentrySpan = parentSpan.startChild(options);\n  try {\n    return fn();\n  } catch (error) {\n    sentrySpan.setStatus('internal_error');\n    throw error;\n  } finally {\n    sentrySpan.finish();\n  }\n}\n\nexport const isSystemCall = (node: CallTreeNode): boolean => {\n  return !node.frame.is_application;\n};\n\nexport const isApplicationCall = (node: CallTreeNode): boolean => {\n  return !!node.frame.is_application;\n};\n\nfunction indexNodeToParents(\n  roots: FlamegraphFrame[],\n  map: Record<string, FlamegraphFrame[]>,\n  leafs: FlamegraphFrame[]\n) {\n  // Index each child node to its parent\n  function indexNode(node: FlamegraphFrame, parent: FlamegraphFrame) {\n    if (!map[node.key]) {\n      map[node.key] = [];\n    }\n\n    map[node.key].push(parent);\n\n    if (!node.children.length) {\n      leafs.push(node);\n      return;\n    }\n\n    for (let i = 0; i < node.children.length; i++) {\n      indexNode(node.children[i], node);\n    }\n  }\n\n  // Begin in each root node\n  for (let i = 0; i < roots.length; i++) {\n    // If the root is a leaf node, push it to the leafs array\n    if (!roots[i].children?.length) {\n      leafs.push(roots[i]);\n    }\n\n    // Init the map for the root in case we havent yet\n    if (!map[roots[i].key]) {\n      map[roots[i].key] = [];\n    }\n\n    // descend down to each child and index them\n    for (let j = 0; j < roots[i].children.length; j++) {\n      indexNode(roots[i].children[j], roots[i]);\n    }\n  }\n}\n\nfunction reverseTrail(\n  nodes: FlamegraphFrame[],\n  parentMap: Record<string, FlamegraphFrame[]>\n): FlamegraphFrame[] {\n  const splits: FlamegraphFrame[] = [];\n\n  for (const n of nodes) {\n    const nc = {\n      ...n,\n      parent: null as FlamegraphFrame | null,\n      children: [] as FlamegraphFrame[],\n    };\n\n    if (!parentMap[n.key]) {\n      continue;\n    }\n\n    for (const parent of parentMap[n.key]) {\n      nc.children.push(...reverseTrail([parent], parentMap));\n    }\n    splits.push(nc);\n  }\n\n  return splits;\n}\n\nexport const invertCallTree = (roots: FlamegraphFrame[]): FlamegraphFrame[] => {\n  const nodeToParentIndex: Record<string, FlamegraphFrame[]> = {};\n  const leafNodes: FlamegraphFrame[] = [];\n\n  indexNodeToParents(roots, nodeToParentIndex, leafNodes);\n  const reversed = reverseTrail(leafNodes, nodeToParentIndex);\n  return reversed;\n};\n","import {Location, LocationDescriptor, Path} from 'history';\n\nimport {Organization, Project} from 'sentry/types';\nimport {Trace} from 'sentry/types/profiling/core';\n\nexport function generateProfilingRoute({orgSlug}: {orgSlug: Organization['slug']}): Path {\n  return `/organizations/${orgSlug}/profiling/`;\n}\n\nexport function generateProfileSummaryRoute({\n  orgSlug,\n  projectSlug,\n}: {\n  orgSlug: Organization['slug'];\n  projectSlug: Project['slug'];\n}): Path {\n  return `/organizations/${orgSlug}/profiling/summary/${projectSlug}/`;\n}\n\nexport function generateProfileFlamechartRoute({\n  orgSlug,\n  projectSlug,\n  profileId,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n}): string {\n  return `/organizations/${orgSlug}/profiling/profile/${projectSlug}/${profileId}/flamechart/`;\n}\n\nexport function generateProfileDetailsRoute({\n  orgSlug,\n  projectSlug,\n  profileId,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n}): string {\n  return `/organizations/${orgSlug}/profiling/profile/${projectSlug}/${profileId}/details/`;\n}\n\nexport function generateProfilingRouteWithQuery({\n  location,\n  orgSlug,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfilingRoute({orgSlug});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n\nexport function generateProfileSummaryRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  transaction,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  projectSlug: Project['slug'];\n  transaction: string;\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileSummaryRoute({orgSlug, projectSlug});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n      transaction,\n    },\n  };\n}\n\nexport function generateProfileFlamechartRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  profileId,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileFlamechartRoute({\n    orgSlug,\n    projectSlug,\n    profileId,\n  });\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n\nexport function generateProfileDetailsRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  profileId,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileDetailsRoute({orgSlug, projectSlug, profileId});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n","/**\n * This is a utility class for profiling (inspired from Speedscope) - we extend it in order to be able to construct\n * a stack of nodes (or call trees) and append weights to them.\n */\nexport class WeightedNode {\n  // Total weight is the weight of the node and all its children.\n  totalWeight: number = 0;\n  // Self weight is the weight of the node itself.\n  selfWeight: number = 0;\n\n  addToTotalWeight(delta: number): number {\n    this.totalWeight += delta;\n    return this.totalWeight;\n  }\n  addToSelfWeight(delta: number): number {\n    this.selfWeight += delta;\n    return this.selfWeight;\n  }\n}\n","import {Location, Query} from 'history';\n\nimport {useRouteContext} from 'sentry/utils/useRouteContext';\n\ntype DefaultQuery<T = string> = {\n  [key: string]: T | T[] | null | undefined;\n};\n\nexport function useLocation<Q extends Query = DefaultQuery>(): Location<Q> {\n  const route = useRouteContext();\n  return route.location;\n}\n","import {useRouteContext} from 'sentry/utils/useRouteContext';\n\nexport function useParams() {\n  const route = useRouteContext();\n  return route.params;\n}\n","import {createContext, useContext, useEffect, useState} from 'react';\nimport * as Sentry from '@sentry/react';\n\nimport {Client} from 'sentry/api';\nimport {ProfileHeader} from 'sentry/components/profiling/profileHeader';\nimport {t} from 'sentry/locale';\nimport {Organization, Project} from 'sentry/types';\nimport {RequestState} from 'sentry/types/core';\nimport {importProfile, ProfileGroup} from 'sentry/utils/profiling/profile/importProfile';\nimport useApi from 'sentry/utils/useApi';\nimport useOrganization from 'sentry/utils/useOrganization';\nimport {useParams} from 'sentry/utils/useParams';\n\nfunction fetchFlamegraphs(\n  api: Client,\n  eventId: string,\n  projectId: Project['id'],\n  organization: Organization\n): Promise<ProfileGroup> {\n  return api\n    .requestPromise(\n      `/projects/${organization.slug}/${projectId}/profiling/profiles/${eventId}/`,\n      {\n        method: 'GET',\n        includeAllArgs: true,\n      }\n    )\n    .then(([data]) => importProfile(data, eventId));\n}\n\ninterface FlamegraphViewProps {\n  children: React.ReactNode;\n}\n\nconst ProfileGroupContext = createContext<\n  | [\n      RequestState<ProfileGroup>,\n      React.Dispatch<React.SetStateAction<RequestState<ProfileGroup>>>\n    ]\n  | null\n>(null);\n\nexport const useProfileGroup = () => {\n  const context = useContext(ProfileGroupContext);\n  if (!context) {\n    throw new Error('useProfileGroup was called outside of ProfileGroupProvider');\n  }\n  return context;\n};\n\nfunction ProfileGroupProvider(props: FlamegraphViewProps): React.ReactElement {\n  const api = useApi();\n  const organization = useOrganization();\n  const params = useParams();\n\n  const [profileGroupState, setProfileGroupState] = useState<RequestState<ProfileGroup>>({\n    type: 'initial',\n  });\n\n  useEffect(() => {\n    if (!params.eventId || !params.projectId) {\n      return undefined;\n    }\n\n    setProfileGroupState({type: 'loading'});\n\n    fetchFlamegraphs(api, params.eventId, params.projectId, organization)\n      .then(importedFlamegraphs => {\n        setProfileGroupState({type: 'resolved', data: importedFlamegraphs});\n      })\n      .catch(err => {\n        const message = err.toString() || t('Error: Unable to load profiles');\n        setProfileGroupState({type: 'errored', error: message});\n        Sentry.captureException(err);\n      });\n\n    return () => {\n      api.clear();\n    };\n  }, [params.eventId, params.projectId, api, organization]);\n\n  return (\n    <ProfileGroupContext.Provider value={[profileGroupState, setProfileGroupState]}>\n      <ProfileHeader />\n      {props.children}\n    </ProfileGroupContext.Provider>\n  );\n}\n\nexport default ProfileGroupProvider;\n"],"names":["useMemo","Breadcrumbs","t","generateProfileDetailsRouteWithQuery","generateProfileFlamechartRouteWithQuery","generateProfileSummaryRouteWithQuery","generateProfilingRouteWithQuery","Breadcrumb","location","organization","trails","crumbs","map","trail","trailToCrumb","type","to","orgSlug","slug","label","preservePageFilters","projectSlug","payload","transaction","generateRouteWithQuery","tab","profileId","Error","JSON","stringify","StyledBreadcrumbs","Link","Layout","useLocation","useOrganization","useParams","useProfileGroup","ProfileHeader","params","profileGroup","data","name","eventId","projectId","gridTemplateColumns","marginBottom","pathname","endsWith","undefined","Frame","WeightedNode","CallTreeNode","constructor","frame","parent","recursive","setParent","setRecursiveThroughNode","node","isRecursive","isDirectRecursive","isLocked","locked","lock","isRoot","Root","stackMarkerToHumanReadable","marker","frameInfo","key","file","resource","line","column","is_application","image","threadId","isSchema","input","Array","isArray","profiles","isEventedProfile","profile","isSampledProfile","isJSProfile","resources","isChromeTraceObjectFormat","isChromeTraceArrayFormat","some","p","ph","isTypescriptChromeTraceArrayFormat","isChromeTraceFormat","createMarkerFrame","resourceId","resolveJSSelfProfilingStack","trace","stackId","frameIndex","callStack","unshift","stack","stacks","frames","frameId","parentId","wrapWithSpan","EventedProfile","ChromeTraceProfile","splitEventsByProcessAndTraceId","collections","Map","i","length","event","pid","tid","processes","get","set","threads","push","chronologicalSort","a","b","ts","reverseChronologicalSort","getNextQueue","beginQueue","endQueue","nextBegin","nextEnd","buildProfile","processId","events","processName","threadName","timelineEvents","filter","e","args","dur","tdur","sort","firstTimestamp","lastTimestamp","frameCache","next","item","pop","createFrameInfoFromEvent","has","enterFrame","topFrameInfo","nextEndInfo","tmp","leaveFrame","totalWeight","build","trim","parseTypescriptChromeTraceArrayFormat","traceID","options","eventsByProcessAndThreadID","op","description","activeProfileIndex","isProfileEvent","isProfileChunk","isThreadmetaData","collectEventsByProfile","sorted","threadNames","profileIdToProcessAndThreadIds","cpuProfiles","id","samples","timeDeltas","startTime","endTime","nodes","cpuProfile","concat","Math","min","max","createFramesIndex","profileNode","children","j","child","collapseSamples","sampleTimes","elapsed","nodeId","delta","parseChromeTraceFormat","_options","_threadNames","_profileId","entries","index","_samples","_sampleTimes","lastOfArray","Profile","appendOrderTree","FromProfile","eventedProfile","endValue","startValue","unit","threadID","lastValue","at","TypeError","addWeightToFrames","weight","weightDelta","addToTotalWeight","top","addToSelfWeight","addWeightsToNodes","value","appendOrderStack","stackTop","lastTop","sampleDelta","weights","last","start","_event","trackSampleStats","leavingStackTop","minFrameDuration","duration","reduce","Number","POSITIVE_INFINITY","Sentry","JSSelfProfile","SampledProfile","createFrameIndex","importProfile","startTransaction","setTag","importJSSelfProfile","importChromeTrace","importSchema","error","setStatus","finish","importSingleProfile","shared","transactionName","tryParseInputString","parse","TRACE_JSON_PARSERS","readFileAsString","Promise","resolve","reject","reader","FileReader","addEventListener","target","result","readAsText","importDroppedProfile","parsers","fileContents","parser","json","markers","startedAt","timestamp","endedAt","jsSelfProfile","appendSample","framesInStack","stackHeight","stackNode","Set","discardedSamplesCount","negativeSamplesCount","Empty","stats","forEach","openFrame","closeFrame","prevStack","sampleIndex","indexOf","toOpen","toOpenNode","sampledProfile","appendSampleWithWeight","n","defined","acc","memoizeByReference","fn","cache","memoizeByReferenceCallback","memoizeVariadicByReference","every","arg","parentSpan","sentrySpan","startChild","isSystemCall","isApplicationCall","indexNodeToParents","roots","leafs","indexNode","reverseTrail","parentMap","splits","nc","invertCallTree","nodeToParentIndex","leafNodes","reversed","generateProfilingRoute","generateProfileSummaryRoute","generateProfileFlamechartRoute","generateProfileDetailsRoute","query","selfWeight","useRouteContext","route","createContext","useContext","useEffect","useState","useApi","fetchFlamegraphs","api","requestPromise","method","includeAllArgs","then","ProfileGroupContext","context","ProfileGroupProvider","props","profileGroupState","setProfileGroupState","importedFlamegraphs","catch","err","message","toString","captureException","clear"],"sourceRoot":""}