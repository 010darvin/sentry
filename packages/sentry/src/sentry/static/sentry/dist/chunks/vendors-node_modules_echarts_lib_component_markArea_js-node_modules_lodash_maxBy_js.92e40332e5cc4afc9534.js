(globalThis["webpackChunk"] = globalThis["webpackChunk"] || []).push([["vendors-node_modules_echarts_lib_component_markArea_js-node_modules_lodash_maxBy_js"],{

/***/ "../node_modules/echarts/lib/component/markArea.js":
/*!*********************************************************!*\
  !*** ../node_modules/echarts/lib/component/markArea.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extension.js */ "../node_modules/echarts/lib/extension.js");
/* harmony import */ var _marker_installMarkArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./marker/installMarkArea.js */ "../node_modules/echarts/lib/component/marker/installMarkArea.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


(0,_extension_js__WEBPACK_IMPORTED_MODULE_0__.use)(_marker_installMarkArea_js__WEBPACK_IMPORTED_MODULE_1__.install);

/***/ }),

/***/ "../node_modules/echarts/lib/component/marker/MarkAreaModel.js":
/*!*********************************************************************!*\
  !*** ../node_modules/echarts/lib/component/marker/MarkAreaModel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "../node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _MarkerModel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerModel.js */ "../node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var MarkAreaModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MarkAreaModel, _super);

  function MarkAreaModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkAreaModel.type;
    return _this;
  }

  MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel);
  };

  MarkAreaModel.type = 'markArea';
  MarkAreaModel.defaultOption = {
    // zlevel: 0,
    // PENDING
    z: 1,
    tooltip: {
      trigger: 'item'
    },
    // markArea should fixed on the coordinate system
    animation: false,
    label: {
      show: true,
      position: 'top'
    },
    itemStyle: {
      // color and borderColor default to use color from series
      // color: 'auto'
      // borderColor: 'auto'
      borderWidth: 0
    },
    emphasis: {
      label: {
        show: true,
        position: 'top'
      }
    }
  };
  return MarkAreaModel;
}(_MarkerModel_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkAreaModel);

/***/ }),

/***/ "../node_modules/echarts/lib/component/marker/MarkAreaView.js":
/*!********************************************************************!*\
  !*** ../node_modules/echarts/lib/component/marker/MarkAreaView.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "../node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zrender/lib/tool/color.js */ "../node_modules/zrender/lib/tool/color.js");
/* harmony import */ var _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../data/SeriesData.js */ "../node_modules/echarts/lib/data/SeriesData.js");
/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/number.js */ "../node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic.js */ "../node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic.js */ "../node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic.js */ "../node_modules/echarts/lib/animation/basicTrasition.js");
/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/states.js */ "../node_modules/echarts/lib/util/states.js");
/* harmony import */ var _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./markerHelper.js */ "../node_modules/echarts/lib/component/marker/markerHelper.js");
/* harmony import */ var _MarkerView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./MarkerView.js */ "../node_modules/echarts/lib/component/marker/MarkerView.js");
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util.js */ "../node_modules/zrender/lib/core/util.js");
/* harmony import */ var _coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/CoordinateSystem.js */ "../node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _MarkerModel_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MarkerModel.js */ "../node_modules/echarts/lib/component/marker/MarkerModel.js");
/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model.js */ "../node_modules/echarts/lib/util/model.js");
/* harmony import */ var _visual_helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../visual/helper.js */ "../node_modules/echarts/lib/visual/helper.js");
/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../label/labelStyle.js */ "../node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/innerStore.js */ "../node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../data/helper/dataValueHelper.js */ "../node_modules/echarts/lib/data/helper/dataValueHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // TODO Optimize on polar
















var inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var markAreaTransform = function (seriesModel, coordSys, maModel, item) {
  var lt = _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__.dataTransform(seriesModel, item[0]);
  var rb = _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__.dataTransform(seriesModel, item[1]); // FIXME make sure lt is less than rb

  var ltCoord = lt.coord;
  var rbCoord = rb.coord;
  ltCoord[0] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve)(ltCoord[0], -Infinity);
  ltCoord[1] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve)(ltCoord[1], -Infinity);
  rbCoord[0] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve)(rbCoord[0], Infinity);
  rbCoord[1] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve)(rbCoord[1], Infinity); // Merge option into one

  var result = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.mergeAll)([{}, lt, rb]);
  result.coord = [lt.coord, rb.coord];
  result.x0 = lt.x;
  result.y0 = lt.y;
  result.x1 = rb.x;
  result.y1 = rb.y;
  return result;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markArea has one dim


function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
}

function markAreaFilter(coordSys, item) {
  var fromCoord = item.coord[0];
  var toCoord = item.coord[1];
  var item0 = {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  };
  var item1 = {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  };

  if ((0,_coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_3__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
    // In case
    // {
    //  markArea: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    } //Directly returning true may also do the work,
    //because markArea will not be shown automatically
    //when it's not included in coordinate system.
    //But filtering ahead can avoid keeping rendering markArea
    //when there are too many of them.


    return _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__.zoneFilter(coordSys, item0, item1);
  }

  return _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__.dataFilter(coordSys, item0) || _markerHelper_js__WEBPACK_IMPORTED_MODULE_1__.dataFilter(coordSys, item1);
} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']


function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = _util_number_js__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get(dims[0]), api.getWidth());
  var yPx = _util_number_js__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get(dims[1]), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
    } else {
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      var pt = [x, y];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point = coordSys.dataToPoint(pt, true);
    }

    if ((0,_coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_3__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);

      if (isInifinity(x)) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);
      } else if (isInifinity(y)) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  return point;
}

var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];

var MarkAreaView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__extends)(MarkAreaView, _super);

  function MarkAreaView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkAreaView.type;
    return _this;
  }

  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var maModel = _MarkerModel_js__WEBPACK_IMPORTED_MODULE_6__["default"].getMarkerModelFromSeries(seriesModel, 'markArea');

      if (maModel) {
        var areaData_1 = maModel.getData();
        areaData_1.each(function (idx) {
          var points = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dimPermutations, function (dim) {
            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
          }); // Layout

          areaData_1.setItemLayout(idx, points);
          var el = areaData_1.getItemGraphicEl(idx);
          el.setShape('points', points);
        });
      }
    }, this);
  };

  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var areaGroupMap = this.markerGroupMap;
    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
      group: new _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__["default"]()
    });
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter

    maModel.setData(areaData); // Update visual and layout of line

    areaData.each(function (idx) {
      // Layout
      var points = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dimPermutations, function (dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
      });
      var xAxisScale = coordSys.getAxis('x').scale;
      var yAxisScale = coordSys.getAxis('y').scale;
      var xAxisExtent = xAxisScale.getExtent();
      var yAxisExtent = yAxisScale.getExtent();
      var xPointExtent = [xAxisScale.parse(areaData.get('x0', idx)), xAxisScale.parse(areaData.get('x1', idx))];
      var yPointExtent = [yAxisScale.parse(areaData.get('y0', idx)), yAxisScale.parse(areaData.get('y1', idx))];
      _util_number_js__WEBPACK_IMPORTED_MODULE_4__.asc(xPointExtent);
      _util_number_js__WEBPACK_IMPORTED_MODULE_4__.asc(yPointExtent);
      var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]); // If none of the area is inside coordSys, allClipped is set to be true
      // in layout so that label will not be displayed. See #12591

      var allClipped = !overlapped;
      areaData.setItemLayout(idx, {
        points: points,
        allClipped: allClipped
      });
      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();
      var color = (0,_visual_helper_js__WEBPACK_IMPORTED_MODULE_8__.getVisualFromData)(seriesData, 'color');

      if (!style.fill) {
        style.fill = color;

        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(style.fill)) {
          style.fill = zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_9__.modifyAlpha(style.fill, 0.4);
        }
      }

      if (!style.stroke) {
        style.stroke = color;
      } // Visual


      areaData.setItemVisual(idx, 'style', style);
    });
    areaData.diff(inner(polygonGroup).data).add(function (idx) {
      var layout = areaData.getItemLayout(idx);

      if (!layout.allClipped) {
        var polygon = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
          shape: {
            points: layout.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }
    }).update(function (newIdx, oldIdx) {
      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);
      var layout = areaData.getItemLayout(newIdx);

      if (!layout.allClipped) {
        if (polygon) {
          _util_graphic_js__WEBPACK_IMPORTED_MODULE_11__.updateProps(polygon, {
            shape: {
              points: layout.points
            }
          }, maModel, newIdx);
        } else {
          polygon = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
            shape: {
              points: layout.points
            }
          });
        }

        areaData.setItemGraphicEl(newIdx, polygon);
        polygonGroup.group.add(polygon);
      } else if (polygon) {
        polygonGroup.group.remove(polygon);
      }
    }).remove(function (idx) {
      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon);
    }).execute();
    areaData.eachItemGraphicEl(function (polygon, idx) {
      var itemModel = areaData.getItemModel(idx);
      var style = areaData.getItemVisual(idx, 'style');
      polygon.useStyle(areaData.getItemVisual(idx, 'style'));
      (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_12__.setLabelStyle)(polygon, (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_12__.getLabelStatesModels)(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || '',
        inheritColor: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(style.fill) ? zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_9__.modifyAlpha(style.fill, 1) : '#000'
      });
      (0,_util_states_js__WEBPACK_IMPORTED_MODULE_13__.setStatesStylesFromModel)(polygon, itemModel);
      (0,_util_states_js__WEBPACK_IMPORTED_MODULE_13__.toggleHoverEmphasis)(polygon, null, null, itemModel.get(['emphasis', 'disabled']));
      (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_14__.getECData)(polygon).dataModel = maModel;
    });
    inner(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');
  };

  MarkAreaView.type = 'markArea';
  return MarkAreaView;
}(_MarkerView_js__WEBPACK_IMPORTED_MODULE_15__["default"]);

function createList(coordSys, seriesModel, maModel) {
  var areaData;
  var dataDims;
  var dims = ['x0', 'y0', 'x1', 'y1'];

  if (coordSys) {
    var coordDimsInfos_1 = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(coordSys && coordSys.dimensions, function (coordDim) {
      var data = seriesModel.getData();
      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.extend)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, info), {
        name: coordDim,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    dataDims = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dims, function (dim, idx) {
      return {
        name: dim,
        type: coordDimsInfos_1[idx % 2].type
      };
    });
    areaData = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_16__["default"](dataDims, maModel);
  } else {
    dataDims = [{
      name: 'value',
      type: 'float'
    }];
    areaData = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_16__["default"](dataDims, maModel);
  }

  var optData = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(maModel.get('data'), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markAreaTransform, seriesModel, coordSys, maModel));

  if (coordSys) {
    optData = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.filter)(optData, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markAreaFilter, coordSys));
  }

  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {
    // TODO should convert to ParsedValue?
    var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    return (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_17__.parseDataValue)(rawVal, dataDims[dimIndex]);
  } : function (item, dimName, dataIndex, dimIndex) {
    return (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_17__.parseDataValue)(item.value, dataDims[dimIndex]);
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkAreaView);

/***/ }),

/***/ "../node_modules/echarts/lib/component/marker/installMarkArea.js":
/*!***********************************************************************!*\
  !*** ../node_modules/echarts/lib/component/marker/installMarkArea.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _checkMarkerInSeries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checkMarkerInSeries.js */ "../node_modules/echarts/lib/component/marker/checkMarkerInSeries.js");
/* harmony import */ var _MarkAreaModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkAreaModel.js */ "../node_modules/echarts/lib/component/marker/MarkAreaModel.js");
/* harmony import */ var _MarkAreaView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkAreaView.js */ "../node_modules/echarts/lib/component/marker/MarkAreaView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_MarkAreaModel_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  registers.registerComponentView(_MarkAreaView_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  registers.registerPreprocessor(function (opt) {
    if ((0,_checkMarkerInSeries_js__WEBPACK_IMPORTED_MODULE_2__["default"])(opt.series, 'markArea')) {
      // Make sure markArea component is enabled
      opt.markArea = opt.markArea || {};
    }
  });
}

/***/ }),

/***/ "../node_modules/lodash/maxBy.js":
/*!***************************************!*\
  !*** ../node_modules/lodash/maxBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "../node_modules/lodash/_baseExtremum.js"),
    baseGt = __webpack_require__(/*! ./_baseGt */ "../node_modules/lodash/_baseGt.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "../node_modules/lodash/_baseIteratee.js");

/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
function maxBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)
    : undefined;
}

module.exports = maxBy;


/***/ })

}]);
//# sourceMappingURL=../sourcemaps/vendors-node_modules_echarts_lib_component_markArea_js-node_modules_lodash_maxBy_js.32afb57d9098a6cbae7c178a04086050.js.map